
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000180 <Reset_Handler>:
 8000180:	b672      	cpsid	i
 8000182:	4826      	ldr	r0, [pc, #152]	; (800021c <endfiniloop+0x4>)
 8000184:	f380 8809 	msr	PSP, r0
 8000188:	2002      	movs	r0, #2
 800018a:	f380 8814 	msr	CONTROL, r0
 800018e:	f3bf 8f6f 	isb	sy
 8000192:	f000 f87d 	bl	8000290 <__core_init>
 8000196:	f001 f9a3 	bl	80014e0 <__early_init>
 800019a:	4821      	ldr	r0, [pc, #132]	; (8000220 <endfiniloop+0x8>)
 800019c:	4921      	ldr	r1, [pc, #132]	; (8000224 <endfiniloop+0xc>)
 800019e:	4a22      	ldr	r2, [pc, #136]	; (8000228 <endfiniloop+0x10>)

080001a0 <msloop>:
 80001a0:	4291      	cmp	r1, r2
 80001a2:	bf3c      	itt	cc
 80001a4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001a8:	f7ff bffa 	bcc.w	80001a0 <msloop>
 80001ac:	491f      	ldr	r1, [pc, #124]	; (800022c <endfiniloop+0x14>)
 80001ae:	4a1b      	ldr	r2, [pc, #108]	; (800021c <endfiniloop+0x4>)

080001b0 <psloop>:
 80001b0:	4291      	cmp	r1, r2
 80001b2:	bf3c      	itt	cc
 80001b4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001b8:	f7ff bffa 	bcc.w	80001b0 <psloop>
 80001bc:	491c      	ldr	r1, [pc, #112]	; (8000230 <endfiniloop+0x18>)
 80001be:	4a1d      	ldr	r2, [pc, #116]	; (8000234 <endfiniloop+0x1c>)
 80001c0:	4b1d      	ldr	r3, [pc, #116]	; (8000238 <endfiniloop+0x20>)

080001c2 <dloop>:
 80001c2:	429a      	cmp	r2, r3
 80001c4:	bf3e      	ittt	cc
 80001c6:	f851 0b04 	ldrcc.w	r0, [r1], #4
 80001ca:	f842 0b04 	strcc.w	r0, [r2], #4
 80001ce:	f7ff bff8 	bcc.w	80001c2 <dloop>
 80001d2:	2000      	movs	r0, #0
 80001d4:	4919      	ldr	r1, [pc, #100]	; (800023c <endfiniloop+0x24>)
 80001d6:	4a1a      	ldr	r2, [pc, #104]	; (8000240 <endfiniloop+0x28>)

080001d8 <bloop>:
 80001d8:	4291      	cmp	r1, r2
 80001da:	bf3c      	itt	cc
 80001dc:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e0:	f7ff bffa 	bcc.w	80001d8 <bloop>
 80001e4:	f000 f86c 	bl	80002c0 <__init_ram_areas>
 80001e8:	f000 f85a 	bl	80002a0 <__late_init>
 80001ec:	4c15      	ldr	r4, [pc, #84]	; (8000244 <endfiniloop+0x2c>)
 80001ee:	4d16      	ldr	r5, [pc, #88]	; (8000248 <endfiniloop+0x30>)

080001f0 <initloop>:
 80001f0:	42ac      	cmp	r4, r5
 80001f2:	f280 8005 	bge.w	8000200 <endinitloop>
 80001f6:	f854 1b04 	ldr.w	r1, [r4], #4
 80001fa:	4788      	blx	r1
 80001fc:	f7ff bff8 	b.w	80001f0 <initloop>

08000200 <endinitloop>:
 8000200:	f001 fc0e 	bl	8001a20 <main>
 8000204:	4c11      	ldr	r4, [pc, #68]	; (800024c <endfiniloop+0x34>)
 8000206:	4d12      	ldr	r5, [pc, #72]	; (8000250 <endfiniloop+0x38>)

08000208 <finiloop>:
 8000208:	42ac      	cmp	r4, r5
 800020a:	f280 8005 	bge.w	8000218 <endfiniloop>
 800020e:	f854 1b04 	ldr.w	r1, [r4], #4
 8000212:	4788      	blx	r1
 8000214:	f7ff bff8 	b.w	8000208 <finiloop>

08000218 <endfiniloop>:
 8000218:	f000 b84a 	b.w	80002b0 <__default_exit>
 800021c:	20000800 	.word	0x20000800
 8000220:	55555555 	.word	0x55555555
 8000224:	20000000 	.word	0x20000000
 8000228:	20000400 	.word	0x20000400
 800022c:	20000400 	.word	0x20000400
 8000230:	08001be0 	.word	0x08001be0
 8000234:	20000800 	.word	0x20000800
 8000238:	20000800 	.word	0x20000800
 800023c:	20000800 	.word	0x20000800
 8000240:	20000bb0 	.word	0x20000bb0
 8000244:	08000180 	.word	0x08000180
 8000248:	08000180 	.word	0x08000180
 800024c:	08000180 	.word	0x08000180
 8000250:	08000180 	.word	0x08000180
	...

08000260 <_port_switch>:
 8000260:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000264:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000268:	68c3      	ldr	r3, [r0, #12]
 800026a:	469d      	mov	sp, r3
 800026c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000270 <_port_thread_start>:
 8000270:	2300      	movs	r3, #0
 8000272:	f383 8811 	msr	BASEPRI, r3
 8000276:	4628      	mov	r0, r5
 8000278:	47a0      	blx	r4
 800027a:	2000      	movs	r0, #0
 800027c:	f000 fb88 	bl	8000990 <chThdExit>

08000280 <_port_switch_from_isr>:
 8000280:	f000 fad6 	bl	8000830 <chSchDoReschedule>

08000284 <_port_exit_from_isr>:
 8000284:	df00      	svc	0
 8000286:	e7fe      	b.n	8000286 <_port_exit_from_isr+0x2>
	...

08000290 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000290:	4770      	bx	lr
 8000292:	bf00      	nop
 8000294:	f3af 8000 	nop.w
 8000298:	f3af 8000 	nop.w
 800029c:	f3af 8000 	nop.w

080002a0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80002a0:	4770      	bx	lr
 80002a2:	bf00      	nop
 80002a4:	f3af 8000 	nop.w
 80002a8:	f3af 8000 	nop.w
 80002ac:	f3af 8000 	nop.w

080002b0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80002b0:	e7fe      	b.n	80002b0 <__default_exit>
 80002b2:	bf00      	nop
 80002b4:	f3af 8000 	nop.w
 80002b8:	f3af 8000 	nop.w
 80002bc:	f3af 8000 	nop.w

080002c0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80002c0:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80002c4:	f641 2780 	movw	r7, #6784	; 0x1a80
 80002c8:	f6c0 0700 	movt	r7, #2048	; 0x800
 80002cc:	f107 0c80 	add.w	ip, r7, #128	; 0x80
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80002d0:	2400      	movs	r4, #0
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;
 80002d2:	687e      	ldr	r6, [r7, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80002d4:	68bd      	ldr	r5, [r7, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 80002d6:	6839      	ldr	r1, [r7, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80002d8:	42ae      	cmp	r6, r5
 80002da:	d226      	bcs.n	800032a <__init_ram_areas+0x6a>
      *p = *tp;
 80002dc:	460a      	mov	r2, r1
 80002de:	f852 8b04 	ldr.w	r8, [r2], #4
 80002e2:	4633      	mov	r3, r6
 80002e4:	43f0      	mvns	r0, r6
 80002e6:	f843 8b04 	str.w	r8, [r3], #4
 80002ea:	1828      	adds	r0, r5, r0
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80002ec:	42ab      	cmp	r3, r5
 80002ee:	f3c0 0080 	ubfx	r0, r0, #2, #1
 80002f2:	d214      	bcs.n	800031e <__init_ram_areas+0x5e>
 80002f4:	b128      	cbz	r0, 8000302 <__init_ram_areas+0x42>
      *p = *tp;
 80002f6:	6849      	ldr	r1, [r1, #4]
 80002f8:	3204      	adds	r2, #4
 80002fa:	f843 1b04 	str.w	r1, [r3], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80002fe:	42ab      	cmp	r3, r5
 8000300:	d20d      	bcs.n	800031e <__init_ram_areas+0x5e>
      *p = *tp;
 8000302:	4610      	mov	r0, r2
 8000304:	f850 8b04 	ldr.w	r8, [r0], #4
 8000308:	4619      	mov	r1, r3
 800030a:	f841 8b04 	str.w	r8, [r1], #4
 800030e:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8000312:	1d02      	adds	r2, r0, #4
 8000314:	f8c3 8004 	str.w	r8, [r3, #4]
      p++;
 8000318:	1d0b      	adds	r3, r1, #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800031a:	42ab      	cmp	r3, r5
 800031c:	d3f1      	bcc.n	8000302 <__init_ram_areas+0x42>
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800031e:	43f3      	mvns	r3, r6
 8000320:	195a      	adds	r2, r3, r5
 8000322:	f022 0503 	bic.w	r5, r2, #3
 8000326:	3504      	adds	r5, #4
 8000328:	1976      	adds	r6, r6, r5
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800032a:	68f9      	ldr	r1, [r7, #12]
 800032c:	428e      	cmp	r6, r1
 800032e:	d214      	bcs.n	800035a <__init_ram_areas+0x9a>
      *p = 0;
 8000330:	4633      	mov	r3, r6
 8000332:	43f2      	mvns	r2, r6
 8000334:	f843 4b04 	str.w	r4, [r3], #4
 8000338:	1888      	adds	r0, r1, r2
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800033a:	428b      	cmp	r3, r1
 800033c:	f3c0 0280 	ubfx	r2, r0, #2, #1
 8000340:	d20b      	bcs.n	800035a <__init_ram_areas+0x9a>
 8000342:	b11a      	cbz	r2, 800034c <__init_ram_areas+0x8c>
      *p = 0;
 8000344:	f843 4b04 	str.w	r4, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000348:	428b      	cmp	r3, r1
 800034a:	d206      	bcs.n	800035a <__init_ram_areas+0x9a>
      *p = 0;
 800034c:	4618      	mov	r0, r3
 800034e:	f840 4b04 	str.w	r4, [r0], #4
 8000352:	605c      	str	r4, [r3, #4]
      p++;
 8000354:	1d03      	adds	r3, r0, #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000356:	428b      	cmp	r3, r1
 8000358:	d3f8      	bcc.n	800034c <__init_ram_areas+0x8c>
      *p = 0;
      p++;
    }
    rap++;
 800035a:	3710      	adds	r7, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800035c:	4567      	cmp	r7, ip
 800035e:	d3b8      	bcc.n	80002d2 <__init_ram_areas+0x12>
#endif
}
 8000360:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8000364:	4770      	bx	lr
 8000366:	bf00      	nop
 8000368:	f3af 8000 	nop.w
 800036c:	f3af 8000 	nop.w

08000370 <_unhandled_exception>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8000370:	e7fe      	b.n	8000370 <_unhandled_exception>
 8000372:	bf00      	nop
 8000374:	f3af 8000 	nop.w
 8000378:	f3af 8000 	nop.w
 800037c:	f3af 8000 	nop.w

08000380 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000380:	e7fe      	b.n	8000380 <_idle_thread>
 8000382:	bf00      	nop
 8000384:	f3af 8000 	nop.w
 8000388:	f3af 8000 	nop.w
 800038c:	f3af 8000 	nop.w

08000390 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000390:	f44f 4c6d 	mov.w	ip, #60672	; 0xed00
 8000394:	f2ce 0c00 	movt	ip, #57344	; 0xe000
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8000398:	b530      	push	{r4, r5, lr}
 800039a:	2400      	movs	r4, #0
 800039c:	f8cc 4008 	str.w	r4, [ip, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80003a0:	f8dc 300c 	ldr.w	r3, [ip, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80003a4:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
 80003a8:	f44f 7540 	mov.w	r5, #768	; 0x300
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80003ac:	ea03 0e01 	and.w	lr, r3, r1
  reg_value  =  (reg_value                                   |
 80003b0:	f2c0 55fa 	movt	r5, #1530	; 0x5fa
 80003b4:	ea4e 0005 	orr.w	r0, lr, r5

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80003b8:	f64e 53f0 	movw	r3, #60912	; 0xedf0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80003bc:	f8cc 000c 	str.w	r0, [ip, #12]
 80003c0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80003c4:	68da      	ldr	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80003c6:	f44f 5e80 	mov.w	lr, #4096	; 0x1000

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80003ca:	f042 7580 	orr.w	r5, r2, #16777216	; 0x1000000
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80003ce:	f2ce 0e00 	movt	lr, #57344	; 0xe000

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80003d2:	60dd      	str	r5, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80003d4:	f8de 1000 	ldr.w	r1, [lr]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80003d8:	2220      	movs	r2, #32
 80003da:	f041 0001 	orr.w	r0, r1, #1
 80003de:	2310      	movs	r3, #16
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80003e0:	4d1a      	ldr	r5, [pc, #104]	; (800044c <chSysInit+0xbc>)
 80003e2:	f8ce 0000 	str.w	r0, [lr]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80003e6:	b083      	sub	sp, #12
 80003e8:	f88c 301f 	strb.w	r3, [ip, #31]
 80003ec:	f88c 2022 	strb.w	r2, [ip, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 80003f0:	f000 f956 	bl	80006a0 <_scheduler_init>
  _vt_init();
 80003f4:	f000 f87c 	bl	80004f0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80003f8:	f000 fb2a 	bl	8000a50 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80003fc:	f000 fcb0 	bl	8000d60 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8000400:	f000 fce6 	bl	8000dd0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000404:	4628      	mov	r0, r5
 8000406:	2140      	movs	r1, #64	; 0x40
 8000408:	f000 fa1a 	bl	8000840 <_thread_init>
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800040c:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800040e:	f845 0c14 	str.w	r0, [r5, #-20]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8000412:	7702      	strb	r2, [r0, #28]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000414:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000418:	b662      	cpsie	i
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 800041a:	f641 3110 	movw	r1, #6928	; 0x1b10
 800041e:	f855 0c14 	ldr.w	r0, [r5, #-20]
 8000422:	f6c0 0100 	movt	r1, #2048	; 0x800
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8000426:	f240 3381 	movw	r3, #897	; 0x381
 800042a:	6181      	str	r1, [r0, #24]
 800042c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000430:	f105 004c 	add.w	r0, r5, #76	; 0x4c
 8000434:	21d8      	movs	r1, #216	; 0xd8
 8000436:	9400      	str	r4, [sp, #0]
 8000438:	f000 fa5a 	bl	80008f0 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 800043c:	f641 3300 	movw	r3, #6912	; 0x1b00
 8000440:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000444:	6183      	str	r3, [r0, #24]
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
  }
#endif
}
 8000446:	b003      	add	sp, #12
 8000448:	bd30      	pop	{r4, r5, pc}
 800044a:	bf00      	nop
 800044c:	2000082c 	.word	0x2000082c

08000450 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000450:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8000454:	f640 0400 	movw	r4, #2048	; 0x800
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000458:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 800045c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000460:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
 8000464:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000466:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
 8000468:	b280      	uxth	r0, r0
 800046a:	ebc1 0c00 	rsb	ip, r1, r0
 800046e:	891a      	ldrh	r2, [r3, #8]
 8000470:	fa1f f58c 	uxth.w	r5, ip
 8000474:	42aa      	cmp	r2, r5
 8000476:	b083      	sub	sp, #12
 8000478:	f104 051c 	add.w	r5, r4, #28
 800047c:	d81b      	bhi.n	80004b6 <chSysTimerHandlerI+0x66>
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 800047e:	2600      	movs	r6, #0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000480:	f04f 0920 	mov.w	r9, #32
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000484:	6818      	ldr	r0, [r3, #0]
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000486:	188a      	adds	r2, r1, r2
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8000488:	42a8      	cmp	r0, r5
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 800048a:	84e2      	strh	r2, [r4, #38]	; 0x26

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 800048c:	68df      	ldr	r7, [r3, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800048e:	6045      	str	r5, [r0, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8000490:	61e0      	str	r0, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 8000492:	60de      	str	r6, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8000494:	d020      	beq.n	80004d8 <chSysTimerHandlerI+0x88>
 8000496:	f386 8811 	msr	BASEPRI, r6
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 800049a:	6918      	ldr	r0, [r3, #16]
 800049c:	47b8      	blx	r7
 800049e:	f389 8811 	msr	BASEPRI, r9
 80004a2:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 80004a6:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80004a8:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
 80004aa:	b280      	uxth	r0, r0
 80004ac:	1a47      	subs	r7, r0, r1
 80004ae:	891a      	ldrh	r2, [r3, #8]
 80004b0:	b2bf      	uxth	r7, r7
 80004b2:	42ba      	cmp	r2, r7
 80004b4:	d9e6      	bls.n	8000484 <chSysTimerHandlerI+0x34>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80004b6:	42ab      	cmp	r3, r5
 80004b8:	d013      	beq.n	80004e2 <chSysTimerHandlerI+0x92>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 80004ba:	188a      	adds	r2, r1, r2
 80004bc:	ebc0 0c02 	rsb	ip, r0, r2
 80004c0:	fa1f f38c 	uxth.w	r3, ip
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80004c4:	2b01      	cmp	r3, #1
 80004c6:	bf98      	it	ls
 80004c8:	2302      	movls	r3, #2
  }
  port_timer_set_alarm(now + delta);
 80004ca:	1819      	adds	r1, r3, r0
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 80004cc:	b288      	uxth	r0, r1
#endif
  chVTDoTickI();
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 80004ce:	b003      	add	sp, #12
 80004d0:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80004d4:	f000 bcfc 	b.w	8000ed0 <stSetAlarm>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 80004d8:	9301      	str	r3, [sp, #4]
 80004da:	f000 fcf1 	bl	8000ec0 <stStopAlarm>
 80004de:	9b01      	ldr	r3, [sp, #4]
 80004e0:	e7d9      	b.n	8000496 <chSysTimerHandlerI+0x46>
 80004e2:	b003      	add	sp, #12
 80004e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80004e8:	f3af 8000 	nop.w
 80004ec:	f3af 8000 	nop.w

080004f0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80004f0:	f640 0300 	movw	r3, #2048	; 0x800
 80004f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004f8:	f103 011c 	add.w	r1, r3, #28
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 80004fc:	f04f 30ff 	mov.w	r0, #4294967295
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8000500:	2200      	movs	r2, #0
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8000502:	61d9      	str	r1, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000504:	6219      	str	r1, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000506:	8498      	strh	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8000508:	84da      	strh	r2, [r3, #38]	; 0x26
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800050a:	4770      	bx	lr
 800050c:	f3af 8000 	nop.w

08000510 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000512:	f640 0600 	movw	r6, #2048	; 0x800
 8000516:	f2c2 0600 	movt	r6, #8192	; 0x2000
 800051a:	4637      	mov	r7, r6
 800051c:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8000520:	f8d4 c024 	ldr.w	ip, [r4, #36]	; 0x24
 8000524:	f857 4f1c 	ldr.w	r4, [r7, #28]!
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000528:	2901      	cmp	r1, #1
 800052a:	bf98      	it	ls
 800052c:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800052e:	42bc      	cmp	r4, r7
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000530:	4605      	mov	r5, r0
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8000532:	6103      	str	r3, [r0, #16]
  vtp->vt_func = vtfunc;
 8000534:	60c2      	str	r2, [r0, #12]
 8000536:	fa1f fc8c 	uxth.w	ip, ip
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800053a:	d024      	beq.n	8000586 <chVTDoSetI+0x76>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.vt_next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.vt_lasttime + delay;
 800053c:	8cf2      	ldrh	r2, [r6, #38]	; 0x26

    if (delta < now - ch.vtlist.vt_lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
 800053e:	8923      	ldrh	r3, [r4, #8]
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.vt_next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.vt_lasttime + delay;
 8000540:	ebc2 000c 	rsb	r0, r2, ip
 8000544:	180f      	adds	r7, r1, r0
 8000546:	b2bf      	uxth	r7, r7

    if (delta < now - ch.vtlist.vt_lasttime) {
 8000548:	4287      	cmp	r7, r0
 800054a:	da14      	bge.n	8000576 <chVTDoSetI+0x66>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
    p = p->vt_next;
 800054c:	6824      	ldr	r4, [r4, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 800054e:	1af9      	subs	r1, r7, r3
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 8000550:	8923      	ldrh	r3, [r4, #8]
    delta -= p->vt_delta;
 8000552:	b28f      	uxth	r7, r1
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 8000554:	42bb      	cmp	r3, r7
 8000556:	d3f9      	bcc.n	800054c <chVTDoSetI+0x3c>
  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
  p->vt_prev = vtp;
  vtp->vt_delta = delta
 8000558:	812f      	strh	r7, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800055a:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800055e:	6860      	ldr	r0, [r4, #4]
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000560:	ebc7 070c 	rsb	r7, r7, ip
  ch.vtlist.vt_delta = (systime_t)-1;
 8000564:	f04f 33ff 	mov.w	r3, #4294967295
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8000568:	602c      	str	r4, [r5, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800056a:	6068      	str	r0, [r5, #4]
  vtp->vt_prev->vt_next = vtp;
 800056c:	6005      	str	r5, [r0, #0]
  p->vt_prev = vtp;
 800056e:	6065      	str	r5, [r4, #4]
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000570:	8127      	strh	r7, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000572:	84b3      	strh	r3, [r6, #36]	; 0x24
}
 8000574:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
      p = p->vt_next;
    }
    else if (delta < p->vt_delta) {
 8000576:	429f      	cmp	r7, r3
 8000578:	d2ec      	bcs.n	8000554 <chVTDoSetI+0x44>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 800057a:	18ba      	adds	r2, r7, r2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 800057c:	b290      	uxth	r0, r2
 800057e:	f000 fca7 	bl	8000ed0 <stSetAlarm>
 8000582:	8923      	ldrh	r3, [r4, #8]
 8000584:	e7e6      	b.n	8000554 <chVTDoSetI+0x44>
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8000586:	eb01 000c 	add.w	r0, r1, ip
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {

  stStartAlarm(time);
 800058a:	b280      	uxth	r0, r0
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 800058c:	f8a6 c026 	strh.w	ip, [r6, #38]	; 0x26
      ch.vtlist.vt_next = vtp;
 8000590:	61f5      	str	r5, [r6, #28]
      ch.vtlist.vt_prev = vtp;
 8000592:	6235      	str	r5, [r6, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8000594:	602c      	str	r4, [r5, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000596:	606c      	str	r4, [r5, #4]
      vtp->vt_delta = delay;
 8000598:	8129      	strh	r1, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
}
 800059a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 800059e:	f000 bc87 	b.w	8000eb0 <stStartAlarm>
 80005a2:	bf00      	nop
 80005a4:	f3af 8000 	nop.w
 80005a8:	f3af 8000 	nop.w
 80005ac:	f3af 8000 	nop.w

080005b0 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 80005b0:	f640 0300 	movw	r3, #2048	; 0x800
 80005b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005b8:	69da      	ldr	r2, [r3, #28]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80005ba:	b470      	push	{r4, r5, r6}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 80005bc:	4282      	cmp	r2, r0
 80005be:	d011      	beq.n	80005e4 <chVTDoResetI+0x34>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 80005c0:	6841      	ldr	r1, [r0, #4]
 80005c2:	6802      	ldr	r2, [r0, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80005c4:	331c      	adds	r3, #28

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 80005c6:	600a      	str	r2, [r1, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 80005c8:	6802      	ldr	r2, [r0, #0]
 80005ca:	6051      	str	r1, [r2, #4]
    vtp->vt_func = NULL;
 80005cc:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80005ce:	429a      	cmp	r2, r3
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;
 80005d0:	60c1      	str	r1, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80005d2:	d005      	beq.n	80005e0 <chVTDoResetI+0x30>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 80005d4:	f8b0 c008 	ldrh.w	ip, [r0, #8]
 80005d8:	8910      	ldrh	r0, [r2, #8]
 80005da:	eb0c 0300 	add.w	r3, ip, r0
 80005de:	8113      	strh	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80005e0:	bc70      	pop	{r4, r5, r6}
 80005e2:	4770      	bx	lr

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80005e4:	6811      	ldr	r1, [r2, #0]
 80005e6:	4618      	mov	r0, r3
 80005e8:	f840 1f1c 	str.w	r1, [r0, #28]!
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 80005ec:	2400      	movs	r4, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80005ee:	4281      	cmp	r1, r0
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80005f0:	6048      	str	r0, [r1, #4]
  vtp->vt_func = NULL;
 80005f2:	60d4      	str	r4, [r2, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80005f4:	d01d      	beq.n	8000632 <chVTDoResetI+0x82>
 80005f6:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 80005fa:	6a66      	ldr	r6, [r4, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80005fc:	8cd8      	ldrh	r0, [r3, #38]	; 0x26

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80005fe:	8915      	ldrh	r5, [r2, #8]
 8000600:	890c      	ldrh	r4, [r1, #8]
 8000602:	b2b2      	uxth	r2, r6
 8000604:	192b      	adds	r3, r5, r4
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8000606:	ebc0 0c02 	rsb	ip, r0, r2

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 800060a:	b29b      	uxth	r3, r3
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 800060c:	fa1f f08c 	uxth.w	r0, ip

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8000610:	4283      	cmp	r3, r0

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8000612:	810b      	strh	r3, [r1, #8]
  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8000614:	d9e4      	bls.n	80005e0 <chVTDoResetI+0x30>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8000616:	1a1b      	subs	r3, r3, r0
 8000618:	fa1f fc83 	uxth.w	ip, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800061c:	f1bc 0f01 	cmp.w	ip, #1
 8000620:	bf98      	it	ls
 8000622:	f04f 0c02 	movls.w	ip, #2
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8000626:	eb0c 0102 	add.w	r1, ip, r2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 800062a:	b288      	uxth	r0, r1
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800062c:	bc70      	pop	{r4, r5, r6}
 800062e:	f000 bc4f 	b.w	8000ed0 <stSetAlarm>
 8000632:	bc70      	pop	{r4, r5, r6}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8000634:	f000 bc44 	b.w	8000ec0 <stStopAlarm>
 8000638:	f3af 8000 	nop.w
 800063c:	f3af 8000 	nop.w

08000640 <wakeup>:
 8000640:	2120      	movs	r1, #32
 8000642:	f381 8811 	msr	BASEPRI, r1
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000646:	7f03      	ldrb	r3, [r0, #28]
 8000648:	2b07      	cmp	r3, #7
 800064a:	d80e      	bhi.n	800066a <wakeup+0x2a>
 800064c:	e8df f003 	tbb	[pc, r3]
 8000650:	240d0d20 	.word	0x240d0d20
 8000654:	080d0408 	.word	0x080d0408
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8000658:	6a03      	ldr	r3, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800065a:	689a      	ldr	r2, [r3, #8]
 800065c:	1c51      	adds	r1, r2, #1
 800065e:	6099      	str	r1, [r3, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000660:	e890 000c 	ldmia.w	r0, {r2, r3}
 8000664:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000666:	6801      	ldr	r1, [r0, #0]
 8000668:	604b      	str	r3, [r1, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800066a:	f04f 32ff 	mov.w	r2, #4294967295
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.r_queue;
 800066e:	f640 0300 	movw	r3, #2048	; 0x800
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000672:	6202      	str	r2, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000674:	6881      	ldr	r1, [r0, #8]
 8000676:	2200      	movs	r2, #0
 8000678:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 800067a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  do {
    cp = cp->p_next;
 800067e:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000680:	689a      	ldr	r2, [r3, #8]
 8000682:	428a      	cmp	r2, r1
 8000684:	d2fb      	bcs.n	800067e <wakeup+0x3e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000686:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000688:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 800068a:	6041      	str	r1, [r0, #4]
  tp->p_prev->p_next = tp;
 800068c:	6008      	str	r0, [r1, #0]
  cp->p_prev = tp;
 800068e:	6058      	str	r0, [r3, #4]
 8000690:	2000      	movs	r0, #0
 8000692:	f380 8811 	msr	BASEPRI, r0
 8000696:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000698:	6a03      	ldr	r3, [r0, #32]
 800069a:	2200      	movs	r2, #0
 800069c:	601a      	str	r2, [r3, #0]
    break;
 800069e:	e7e4      	b.n	800066a <wakeup+0x2a>

080006a0 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80006a0:	f640 0300 	movw	r3, #2048	; 0x800
 80006a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 80006a8:	2200      	movs	r2, #0
 80006aa:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80006ac:	605b      	str	r3, [r3, #4]
 80006ae:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 80006b0:	611b      	str	r3, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 80006b2:	615b      	str	r3, [r3, #20]
#endif
}
 80006b4:	4770      	bx	lr
 80006b6:	bf00      	nop
 80006b8:	f3af 8000 	nop.w
 80006bc:	f3af 8000 	nop.w

080006c0 <chSchReadyI>:
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.r_queue;
 80006c0:	f640 0300 	movw	r3, #2048	; 0x800
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80006c4:	2200      	movs	r2, #0
 80006c6:	6881      	ldr	r1, [r0, #8]
 80006c8:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80006ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  do {
    cp = cp->p_next;
 80006ce:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80006d0:	689a      	ldr	r2, [r3, #8]
 80006d2:	428a      	cmp	r2, r1
 80006d4:	d2fb      	bcs.n	80006ce <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80006d6:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80006d8:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 80006da:	6041      	str	r1, [r0, #4]
  tp->p_prev->p_next = tp;
 80006dc:	6008      	str	r0, [r1, #0]
  cp->p_prev = tp;
 80006de:	6058      	str	r0, [r3, #4]

  return tp;
}
 80006e0:	4770      	bx	lr
 80006e2:	bf00      	nop
 80006e4:	f3af 8000 	nop.w
 80006e8:	f3af 8000 	nop.w
 80006ec:	f3af 8000 	nop.w

080006f0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80006f0:	f640 0300 	movw	r3, #2048	; 0x800
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80006f4:	b410      	push	{r4}
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80006f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80006fa:	681a      	ldr	r2, [r3, #0]
 80006fc:	6999      	ldr	r1, [r3, #24]

  tqp->p_next = tp->p_next;
 80006fe:	6814      	ldr	r4, [r2, #0]
  otp->p_state = newstate;
 8000700:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000702:	2001      	movs	r0, #1
 8000704:	7710      	strb	r0, [r2, #28]
  chSysSwitch(currp, otp);
 8000706:	4610      	mov	r0, r2
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000708:	6063      	str	r3, [r4, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800070a:	601c      	str	r4, [r3, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800070c:	619a      	str	r2, [r3, #24]
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
}
 800070e:	bc10      	pop	{r4}
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8000710:	f7ff bda6 	b.w	8000260 <_port_switch>
 8000714:	f3af 8000 	nop.w
 8000718:	f3af 8000 	nop.w
 800071c:	f3af 8000 	nop.w

08000720 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000720:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000722:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000726:	4299      	cmp	r1, r3
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000728:	b087      	sub	sp, #28
 800072a:	4605      	mov	r5, r0

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800072c:	d017      	beq.n	800075e <chSchGoSleepTimeoutS+0x3e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800072e:	f640 0400 	movw	r4, #2048	; 0x800
 8000732:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000736:	f240 6241 	movw	r2, #1601	; 0x641
 800073a:	f6c0 0200 	movt	r2, #2048	; 0x800
 800073e:	69a3      	ldr	r3, [r4, #24]
 8000740:	a801      	add	r0, sp, #4
 8000742:	f7ff fee5 	bl	8000510 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000746:	4628      	mov	r0, r5
 8000748:	f7ff ffd2 	bl	80006f0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800074c:	9804      	ldr	r0, [sp, #16]
 800074e:	b110      	cbz	r0, 8000756 <chSchGoSleepTimeoutS+0x36>
      chVTDoResetI(&vt);
 8000750:	a801      	add	r0, sp, #4
 8000752:	f7ff ff2d 	bl	80005b0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8000756:	69a1      	ldr	r1, [r4, #24]
}
 8000758:	6a08      	ldr	r0, [r1, #32]
 800075a:	b007      	add	sp, #28
 800075c:	bd30      	pop	{r4, r5, pc}
 800075e:	f640 0400 	movw	r4, #2048	; 0x800
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000762:	f7ff ffc5 	bl	80006f0 <chSchGoSleepS>
 8000766:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800076a:	e7f4      	b.n	8000756 <chSchGoSleepTimeoutS+0x36>
 800076c:	f3af 8000 	nop.w

08000770 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000770:	f640 0200 	movw	r2, #2048	; 0x800
 8000774:	f2c2 0200 	movt	r2, #8192	; 0x2000
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000778:	b430      	push	{r4, r5}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800077a:	6994      	ldr	r4, [r2, #24]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800077c:	4603      	mov	r3, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800077e:	6885      	ldr	r5, [r0, #8]
 8000780:	68a0      	ldr	r0, [r4, #8]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000782:	6219      	str	r1, [r3, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000784:	2100      	movs	r1, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000786:	4285      	cmp	r5, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000788:	bf84      	itt	hi
 800078a:	7721      	strbhi	r1, [r4, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 800078c:	4611      	movhi	r1, r2

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800078e:	d80b      	bhi.n	80007a8 <chSchWakeupS+0x38>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000790:	7719      	strb	r1, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8000792:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000794:	6891      	ldr	r1, [r2, #8]
 8000796:	428d      	cmp	r5, r1
 8000798:	d9fb      	bls.n	8000792 <chSchWakeupS+0x22>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800079a:	6850      	ldr	r0, [r2, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800079c:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 800079e:	6058      	str	r0, [r3, #4]
  tp->p_prev->p_next = tp;
 80007a0:	6003      	str	r3, [r0, #0]
  cp->p_prev = tp;
 80007a2:	6053      	str	r3, [r2, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80007a4:	bc30      	pop	{r4, r5}
 80007a6:	4770      	bx	lr
              "invalid state");

  tp->p_state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80007a8:	6809      	ldr	r1, [r1, #0]
  } while (cp->p_prio >= tp->p_prio);
 80007aa:	688d      	ldr	r5, [r1, #8]
 80007ac:	42a8      	cmp	r0, r5
 80007ae:	d9fb      	bls.n	80007a8 <chSchWakeupS+0x38>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80007b0:	6848      	ldr	r0, [r1, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80007b2:	6021      	str	r1, [r4, #0]
  tp->p_prev = cp->p_prev;
 80007b4:	6060      	str	r0, [r4, #4]
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
 80007b6:	604c      	str	r4, [r1, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 80007b8:	2101      	movs	r1, #1
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80007ba:	6004      	str	r4, [r0, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 80007bc:	7719      	strb	r1, [r3, #28]
    chSysSwitch(ntp, otp);
 80007be:	4618      	mov	r0, r3
 80007c0:	4621      	mov	r1, r4
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 80007c2:	6193      	str	r3, [r2, #24]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80007c4:	bc30      	pop	{r4, r5}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80007c6:	f7ff bd4b 	b.w	8000260 <_port_switch>
 80007ca:	bf00      	nop
 80007cc:	f3af 8000 	nop.w

080007d0 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 80007d0:	f640 0000 	movw	r0, #2048	; 0x800
 80007d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
  tprio_t p2 = currp->p_prio;
 80007d8:	6981      	ldr	r1, [r0, #24]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 80007da:	6802      	ldr	r2, [r0, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80007dc:	688b      	ldr	r3, [r1, #8]
 80007de:	6890      	ldr	r0, [r2, #8]
#endif
}
 80007e0:	4298      	cmp	r0, r3
 80007e2:	bf94      	ite	ls
 80007e4:	2000      	movls	r0, #0
 80007e6:	2001      	movhi	r0, #1
 80007e8:	4770      	bx	lr
 80007ea:	bf00      	nop
 80007ec:	f3af 8000 	nop.w

080007f0 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80007f0:	f640 0200 	movw	r2, #2048	; 0x800
 80007f4:	f2c2 0200 	movt	r2, #8192	; 0x2000
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80007f8:	6810      	ldr	r0, [r2, #0]
 80007fa:	6991      	ldr	r1, [r2, #24]

  tqp->p_next = tp->p_next;
 80007fc:	6803      	ldr	r3, [r0, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80007fe:	b430      	push	{r4, r5}
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000800:	605a      	str	r2, [r3, #4]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8000802:	688c      	ldr	r4, [r1, #8]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000804:	2501      	movs	r5, #1
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000806:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000808:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 800080a:	2200      	movs	r2, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800080c:	7705      	strb	r5, [r0, #28]

  otp->p_state = CH_STATE_READY;
 800080e:	770a      	strb	r2, [r1, #28]
 8000810:	e000      	b.n	8000814 <chSchDoRescheduleAhead+0x24>
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8000812:	681b      	ldr	r3, [r3, #0]
 8000814:	689a      	ldr	r2, [r3, #8]
 8000816:	42a2      	cmp	r2, r4
 8000818:	d8fb      	bhi.n	8000812 <chSchDoRescheduleAhead+0x22>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 800081a:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800081c:	600b      	str	r3, [r1, #0]
  otp->p_prev = cp->p_prev;
 800081e:	604a      	str	r2, [r1, #4]
  otp->p_prev->p_next = otp;
 8000820:	6011      	str	r1, [r2, #0]
  cp->p_prev = otp;
 8000822:	6059      	str	r1, [r3, #4]

  chSysSwitch(currp, otp);
}
 8000824:	bc30      	pop	{r4, r5}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8000826:	f7ff bd1b 	b.w	8000260 <_port_switch>
 800082a:	bf00      	nop
 800082c:	f3af 8000 	nop.w

08000830 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8000830:	f7ff bfde 	b.w	80007f0 <chSchDoRescheduleAhead>
 8000834:	f3af 8000 	nop.w
 8000838:	f3af 8000 	nop.w
 800083c:	f3af 8000 	nop.w

08000840 <_thread_init>:
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000840:	f640 0200 	movw	r2, #2048	; 0x800
 8000844:	f2c2 0200 	movt	r2, #8192	; 0x2000
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8000848:	b4f0      	push	{r4, r5, r6, r7}
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800084a:	6955      	ldr	r5, [r2, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800084c:	2400      	movs	r4, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800084e:	f100 0628 	add.w	r6, r0, #40	; 0x28
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000852:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000854:	6081      	str	r1, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000856:	6128      	str	r0, [r5, #16]
 8000858:	6145      	str	r5, [r0, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800085a:	f100 0724 	add.w	r7, r0, #36	; 0x24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800085e:	2502      	movs	r5, #2
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8000860:	63c1      	str	r1, [r0, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8000862:	2101      	movs	r1, #1
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000864:	7705      	strb	r5, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000866:	7744      	strb	r4, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000868:	6384      	str	r4, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800086a:	6344      	str	r4, [r0, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800086c:	7781      	strb	r1, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800086e:	6184      	str	r4, [r0, #24]
  REG_INSERT(tp);
 8000870:	6150      	str	r0, [r2, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000872:	6247      	str	r7, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000874:	6286      	str	r6, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8000876:	62c6      	str	r6, [r0, #44]	; 0x2c
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 8000878:	bcf0      	pop	{r4, r5, r6, r7}
 800087a:	4770      	bx	lr
 800087c:	f3af 8000 	nop.w

08000880 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8000880:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000884:	f1a1 0c24 	sub.w	ip, r1, #36	; 0x24
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000888:	f640 0500 	movw	r5, #2048	; 0x800
 800088c:	f2c2 0500 	movt	r5, #8192	; 0x2000

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000890:	eb00 070c 	add.w	r7, r0, ip
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000894:	f8d5 a014 	ldr.w	sl, [r5, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000898:	f240 2171 	movw	r1, #625	; 0x271
 800089c:	60c7      	str	r7, [r0, #12]
 800089e:	f840 300c 	str.w	r3, [r0, ip]
 80008a2:	9b07      	ldr	r3, [sp, #28]
 80008a4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80008a8:	607b      	str	r3, [r7, #4]
 80008aa:	6239      	str	r1, [r7, #32]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80008ac:	2600      	movs	r6, #0
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 80008ae:	4690      	mov	r8, r2
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80008b0:	f100 0924 	add.w	r9, r0, #36	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80008b4:	f100 0228 	add.w	r2, r0, #40	; 0x28
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80008b8:	2102      	movs	r1, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80008ba:	2301      	movs	r3, #1
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80008bc:	6105      	str	r5, [r0, #16]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80008be:	f8c0 8008 	str.w	r8, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80008c2:	f8ca 0010 	str.w	r0, [sl, #16]
 80008c6:	f8c0 a014 	str.w	sl, [r0, #20]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80008ca:	7701      	strb	r1, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80008cc:	7746      	strb	r6, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80008ce:	f8c0 803c 	str.w	r8, [r0, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 80008d2:	6386      	str	r6, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80008d4:	6346      	str	r6, [r0, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80008d6:	7783      	strb	r3, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80008d8:	6186      	str	r6, [r0, #24]
  REG_INSERT(tp);
 80008da:	6168      	str	r0, [r5, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80008dc:	f8c0 9024 	str.w	r9, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80008e0:	6282      	str	r2, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 80008e2:	62c2      	str	r2, [r0, #44]	; 0x2c
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);

  return _thread_init(tp, prio);
}
 80008e4:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 80008e8:	4770      	bx	lr
 80008ea:	bf00      	nop
 80008ec:	f3af 8000 	nop.w

080008f0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80008f0:	b510      	push	{r4, lr}
 80008f2:	2420      	movs	r4, #32
 80008f4:	b082      	sub	sp, #8
 80008f6:	f384 8811 	msr	BASEPRI, r4
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80008fa:	9c04      	ldr	r4, [sp, #16]
 80008fc:	9400      	str	r4, [sp, #0]
 80008fe:	f7ff ffbf 	bl	8000880 <chThdCreateI>
  chSchWakeupS(tp, MSG_OK);
 8000902:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8000904:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8000906:	f7ff ff33 	bl	8000770 <chSchWakeupS>
 800090a:	2300      	movs	r3, #0
 800090c:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8000910:	4620      	mov	r0, r4
 8000912:	b002      	add	sp, #8
 8000914:	bd10      	pop	{r4, pc}
 8000916:	bf00      	nop
 8000918:	f3af 8000 	nop.w
 800091c:	f3af 8000 	nop.w

08000920 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000920:	b508      	push	{r3, lr}
 8000922:	4601      	mov	r1, r0
 8000924:	2020      	movs	r0, #32
 8000926:	f380 8811 	msr	BASEPRI, r0
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800092a:	2008      	movs	r0, #8
 800092c:	f7ff fef8 	bl	8000720 <chSchGoSleepTimeoutS>
 8000930:	2300      	movs	r3, #0
 8000932:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8000936:	bd08      	pop	{r3, pc}
 8000938:	f3af 8000 	nop.w
 800093c:	f3af 8000 	nop.w

08000940 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8000940:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8000942:	f640 0300 	movw	r3, #2048	; 0x800
 8000946:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800094a:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800094c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800094e:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8000952:	429d      	cmp	r5, r3
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  tp->p_u.exitcode = msg;
 8000954:	6220      	str	r0, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8000956:	d007      	beq.n	8000968 <chThdExitS+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8000958:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800095a:	4618      	mov	r0, r3
 800095c:	6262      	str	r2, [r4, #36]	; 0x24
 800095e:	f7ff feaf 	bl	80006c0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000962:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8000964:	429d      	cmp	r5, r3
 8000966:	d1f7      	bne.n	8000958 <chThdExitS+0x18>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8000968:	7f61      	ldrb	r1, [r4, #29]
 800096a:	0788      	lsls	r0, r1, #30
    REG_REMOVE(tp);
 800096c:	bf01      	itttt	eq
 800096e:	6922      	ldreq	r2, [r4, #16]
 8000970:	6960      	ldreq	r0, [r4, #20]
 8000972:	6102      	streq	r2, [r0, #16]
 8000974:	6922      	ldreq	r2, [r4, #16]
 8000976:	bf08      	it	eq
 8000978:	6150      	streq	r0, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800097a:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 800097c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8000980:	f7ff beb6 	b.w	80006f0 <chSchGoSleepS>
 8000984:	f3af 8000 	nop.w
 8000988:	f3af 8000 	nop.w
 800098c:	f3af 8000 	nop.w

08000990 <chThdExit>:
 8000990:	2320      	movs	r3, #32
 8000992:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8000996:	f7ff bfd3 	b.w	8000940 <chThdExitS>
 800099a:	bf00      	nop
 800099c:	f3af 8000 	nop.w

080009a0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80009a0:	4602      	mov	r2, r0

  if (TIME_IMMEDIATE == timeout) {
 80009a2:	b169      	cbz	r1, 80009c0 <chThdEnqueueTimeoutS+0x20>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80009a4:	f640 0c00 	movw	ip, #2048	; 0x800
 80009a8:	f2c2 0c00 	movt	ip, #8192	; 0x2000
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80009ac:	6840      	ldr	r0, [r0, #4]
 80009ae:	f8dc 3018 	ldr.w	r3, [ip, #24]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 80009b2:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 80009b4:	6058      	str	r0, [r3, #4]
  tp->p_prev->p_next = tp;
 80009b6:	6003      	str	r3, [r0, #0]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80009b8:	2004      	movs	r0, #4
  tqp->p_prev = tp;
 80009ba:	6053      	str	r3, [r2, #4]
 80009bc:	f7ff beb0 	b.w	8000720 <chSchGoSleepTimeoutS>
}
 80009c0:	f04f 30ff 	mov.w	r0, #4294967295
 80009c4:	4770      	bx	lr
 80009c6:	bf00      	nop
 80009c8:	f3af 8000 	nop.w
 80009cc:	f3af 8000 	nop.w

080009d0 <chThdDequeueNextI>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80009d0:	6802      	ldr	r2, [r0, #0]
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80009d2:	b410      	push	{r4}

  if (queue_notempty(tqp)) {
 80009d4:	4290      	cmp	r0, r2
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80009d6:	4603      	mov	r3, r0

  if (queue_notempty(tqp)) {
 80009d8:	d007      	beq.n	80009ea <chThdDequeueNextI+0x1a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80009da:	6814      	ldr	r4, [r2, #0]
  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
  (void) chSchReadyI(tp);
 80009dc:	4610      	mov	r0, r2
 80009de:	601c      	str	r4, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80009e0:	6063      	str	r3, [r4, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80009e2:	6211      	str	r1, [r2, #32]
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80009e4:	bc10      	pop	{r4}
  (void) chSchReadyI(tp);
 80009e6:	f7ff be6b 	b.w	80006c0 <chSchReadyI>
 80009ea:	bc10      	pop	{r4}
 80009ec:	4770      	bx	lr
 80009ee:	bf00      	nop

080009f0 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80009f0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80009f4:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80009f8:	684b      	ldr	r3, [r1, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80009fa:	6083      	str	r3, [r0, #8]
}
 80009fc:	4770      	bx	lr
 80009fe:	bf00      	nop

08000a00 <chTMStopMeasurementX>:
 8000a00:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000a04:	f2ce 0300 	movt	r3, #57344	; 0xe000
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000a08:	f640 0200 	movw	r2, #2048	; 0x800
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000a0c:	b430      	push	{r4, r5}
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000a0e:	6881      	ldr	r1, [r0, #8]
 8000a10:	685c      	ldr	r4, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000a12:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8000a16:	6f13      	ldr	r3, [r2, #112]	; 0x70

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000a18:	68c5      	ldr	r5, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8000a1a:	1a61      	subs	r1, r4, r1
 8000a1c:	1ac9      	subs	r1, r1, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000a1e:	3501      	adds	r5, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000a20:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
 8000a24:	1852      	adds	r2, r2, r1
 8000a26:	f143 0300 	adc.w	r3, r3, #0
  if (tmp->last > tmp->worst) {
 8000a2a:	6844      	ldr	r4, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000a2c:	e9c0 2304 	strd	r2, r3, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 8000a30:	6803      	ldr	r3, [r0, #0]
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8000a32:	42a1      	cmp	r1, r4
    tmp->worst = tmp->last;
 8000a34:	bf88      	it	hi
 8000a36:	6041      	strhi	r1, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 8000a38:	4299      	cmp	r1, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000a3a:	60c5      	str	r5, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8000a3c:	6081      	str	r1, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8000a3e:	bf38      	it	cc
 8000a40:	6001      	strcc	r1, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8000a42:	bc30      	pop	{r4, r5}
 8000a44:	4770      	bx	lr
 8000a46:	bf00      	nop
 8000a48:	f3af 8000 	nop.w
 8000a4c:	f3af 8000 	nop.w

08000a50 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8000a50:	b510      	push	{r4, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8000a52:	f640 0400 	movw	r4, #2048	; 0x800
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8000a56:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8000a58:	2300      	movs	r3, #0
 8000a5a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8000a5e:	f04f 32ff 	mov.w	r2, #4294967295
  tmp->worst      = (rtcnt_t)0;
 8000a62:	e88d 000c 	stmia.w	sp, {r2, r3}
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000a66:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8000a68:	2200      	movs	r2, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8000a6a:	6723      	str	r3, [r4, #112]	; 0x70
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
 8000a6c:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 8000a6e:	9303      	str	r3, [sp, #12]
  tmp->cumulative = (rttime_t)0;
 8000a70:	2300      	movs	r3, #0
 8000a72:	e9cd 2304 	strd	r2, r3, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000a76:	f7ff ffbb 	bl	80009f0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8000a7a:	4668      	mov	r0, sp
 8000a7c:	f7ff ffc0 	bl	8000a00 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8000a80:	9b02      	ldr	r3, [sp, #8]
 8000a82:	6723      	str	r3, [r4, #112]	; 0x70
}
 8000a84:	b006      	add	sp, #24
 8000a86:	bd10      	pop	{r4, pc}
 8000a88:	f3af 8000 	nop.w
 8000a8c:	f3af 8000 	nop.w

08000a90 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8000a90:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000a92:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000a94:	6040      	str	r0, [r0, #4]
 8000a96:	6083      	str	r3, [r0, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8000a98:	4770      	bx	lr
 8000a9a:	bf00      	nop
 8000a9c:	f3af 8000 	nop.w

08000aa0 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000aa0:	6b42      	ldr	r2, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000aa2:	7f03      	ldrb	r3, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000aa4:	430a      	orrs	r2, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000aa6:	2b0a      	cmp	r3, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000aa8:	6342      	str	r2, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000aaa:	d00b      	beq.n	8000ac4 <chEvtSignalI+0x24>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8000aac:	2b0b      	cmp	r3, #11
 8000aae:	d000      	beq.n	8000ab2 <chEvtSignalI+0x12>
 8000ab0:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8000ab2:	6a03      	ldr	r3, [r0, #32]
 8000ab4:	ea02 0103 	and.w	r1, r2, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8000ab8:	428b      	cmp	r3, r1
 8000aba:	d1f9      	bne.n	8000ab0 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000abc:	2200      	movs	r2, #0
 8000abe:	6202      	str	r2, [r0, #32]
    (void) chSchReadyI(tp);
 8000ac0:	f7ff bdfe 	b.w	80006c0 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8000ac4:	6a03      	ldr	r3, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000ac6:	421a      	tst	r2, r3
 8000ac8:	d1f8      	bne.n	8000abc <chEvtSignalI+0x1c>
 8000aca:	4770      	bx	lr
 8000acc:	f3af 8000 	nop.w

08000ad0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000ad0:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8000ad2:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000ad4:	4606      	mov	r6, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000ad6:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000ad8:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000ada:	d00d      	beq.n	8000af8 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->el_flags |= flags;
 8000adc:	68e3      	ldr	r3, [r4, #12]
 8000ade:	432b      	orrs	r3, r5
 8000ae0:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000ae2:	b115      	cbz	r5, 8000aea <chEvtBroadcastFlagsI+0x1a>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8000ae4:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000ae6:	4213      	tst	r3, r2
 8000ae8:	d003      	beq.n	8000af2 <chEvtBroadcastFlagsI+0x22>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8000aea:	6860      	ldr	r0, [r4, #4]
 8000aec:	68a1      	ldr	r1, [r4, #8]
 8000aee:	f7ff ffd7 	bl	8000aa0 <chEvtSignalI>
    }
    elp = elp->el_next;
 8000af2:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000af4:	42a6      	cmp	r6, r4
 8000af6:	d1f1      	bne.n	8000adc <chEvtBroadcastFlagsI+0xc>
 8000af8:	bd70      	pop	{r4, r5, r6, pc}
 8000afa:	bf00      	nop
 8000afc:	f3af 8000 	nop.w

08000b00 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8000b00:	b410      	push	{r4}
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8000b02:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
 8000b04:	9b01      	ldr	r3, [sp, #4]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8000b06:	188a      	adds	r2, r1, r2
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000b08:	2400      	movs	r4, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000b0a:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000b0c:	6040      	str	r0, [r0, #4]
 8000b0e:	6084      	str	r4, [r0, #8]
  iqp->q_buffer  = bp;
 8000b10:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 8000b12:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 8000b14:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
 8000b16:	6102      	str	r2, [r0, #16]
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8000b18:	6203      	str	r3, [r0, #32]
}
 8000b1a:	bc10      	pop	{r4}
 8000b1c:	4770      	bx	lr
 8000b1e:	bf00      	nop

08000b20 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8000b20:	b508      	push	{r3, lr}
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000b22:	6982      	ldr	r2, [r0, #24]
 8000b24:	6943      	ldr	r3, [r0, #20]
 8000b26:	4293      	cmp	r3, r2
 8000b28:	d00f      	beq.n	8000b4a <chIQPutI+0x2a>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000b2a:	6882      	ldr	r2, [r0, #8]
 8000b2c:	3201      	adds	r2, #1
 8000b2e:	6082      	str	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
 8000b30:	f803 1b01 	strb.w	r1, [r3], #1
  if (iqp->q_wrptr >= iqp->q_top) {
 8000b34:	6901      	ldr	r1, [r0, #16]
  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
 8000b36:	6143      	str	r3, [r0, #20]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000b38:	428b      	cmp	r3, r1
 8000b3a:	d301      	bcc.n	8000b40 <chIQPutI+0x20>
    iqp->q_wrptr = iqp->q_buffer;
 8000b3c:	68c3      	ldr	r3, [r0, #12]
 8000b3e:	6143      	str	r3, [r0, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8000b40:	2100      	movs	r1, #0
 8000b42:	f7ff ff45 	bl	80009d0 <chThdDequeueNextI>

  return Q_OK;
 8000b46:	2000      	movs	r0, #0
 8000b48:	bd08      	pop	{r3, pc}
 8000b4a:	6882      	ldr	r2, [r0, #8]
 8000b4c:	2a00      	cmp	r2, #0
 8000b4e:	d0ec      	beq.n	8000b2a <chIQPutI+0xa>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 8000b50:	f06f 0003 	mvn.w	r0, #3
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);

  return Q_OK;
}
 8000b54:	bd08      	pop	{r3, pc}
 8000b56:	bf00      	nop
 8000b58:	f3af 8000 	nop.w
 8000b5c:	f3af 8000 	nop.w

08000b60 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8000b60:	b570      	push	{r4, r5, r6, lr}
 8000b62:	2320      	movs	r3, #32
 8000b64:	4604      	mov	r4, r0
 8000b66:	460e      	mov	r6, r1
 8000b68:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8000b6c:	69c3      	ldr	r3, [r0, #28]
 8000b6e:	b103      	cbz	r3, 8000b72 <chIQGetTimeout+0x12>
    iqp->q_notify(iqp);
 8000b70:	4798      	blx	r3
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8000b72:	68a5      	ldr	r5, [r4, #8]
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8000b74:	4620      	mov	r0, r4
 8000b76:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8000b78:	b935      	cbnz	r5, 8000b88 <chIQGetTimeout+0x28>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8000b7a:	f7ff ff11 	bl	80009a0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000b7e:	2800      	cmp	r0, #0
 8000b80:	daf7      	bge.n	8000b72 <chIQGetTimeout+0x12>
 8000b82:	f385 8811 	msr	BASEPRI, r5
      chSysUnlock();
      return msg;
 8000b86:	bd70      	pop	{r4, r5, r6, pc}
    }
  }

  iqp->q_counter--;
 8000b88:	68a1      	ldr	r1, [r4, #8]
  b = *iqp->q_rdptr++;
 8000b8a:	69a3      	ldr	r3, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000b8c:	1e48      	subs	r0, r1, #1
 8000b8e:	60a0      	str	r0, [r4, #8]
  b = *iqp->q_rdptr++;
 8000b90:	f813 0b01 	ldrb.w	r0, [r3], #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8000b94:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000b96:	61a3      	str	r3, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000b98:	4293      	cmp	r3, r2
    iqp->q_rdptr = iqp->q_buffer;
 8000b9a:	bf24      	itt	cs
 8000b9c:	68e3      	ldrcs	r3, [r4, #12]
 8000b9e:	61a3      	strcs	r3, [r4, #24]
 8000ba0:	2100      	movs	r1, #0
 8000ba2:	f381 8811 	msr	BASEPRI, r1
  }
  chSysUnlock();

  return (msg_t)b;
}
 8000ba6:	bd70      	pop	{r4, r5, r6, pc}
 8000ba8:	f3af 8000 	nop.w
 8000bac:	f3af 8000 	nop.w

08000bb0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8000bb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000bb4:	b083      	sub	sp, #12
 8000bb6:	4604      	mov	r4, r0
 8000bb8:	9101      	str	r1, [sp, #4]
 8000bba:	4615      	mov	r5, r2
 8000bbc:	461f      	mov	r7, r3
  qnotify_t nfy = iqp->q_notify;
 8000bbe:	f8d0 901c 	ldr.w	r9, [r0, #28]
 8000bc2:	f04f 0b20 	mov.w	fp, #32
 8000bc6:	f38b 8811 	msr	BASEPRI, fp
  size_t r = 0;
 8000bca:	f04f 0800 	mov.w	r8, #0
 8000bce:	46c2      	mov	sl, r8

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8000bd0:	f1b9 0f00 	cmp.w	r9, #0
 8000bd4:	d001      	beq.n	8000bda <chIQReadTimeout+0x2a>
      nfy(iqp);
 8000bd6:	4620      	mov	r0, r4
 8000bd8:	47c8      	blx	r9
 8000bda:	68a6      	ldr	r6, [r4, #8]
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8000bdc:	4620      	mov	r0, r4
 8000bde:	4639      	mov	r1, r7
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8000be0:	b94e      	cbnz	r6, 8000bf6 <chIQReadTimeout+0x46>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8000be2:	f7ff fedd 	bl	80009a0 <chThdEnqueueTimeoutS>
 8000be6:	2800      	cmp	r0, #0
 8000be8:	d0f7      	beq.n	8000bda <chIQReadTimeout+0x2a>
 8000bea:	f386 8811 	msr	BASEPRI, r6
      return r;
    }

    chSysLock();
  }
}
 8000bee:	4640      	mov	r0, r8
 8000bf0:	b003      	add	sp, #12
 8000bf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000bf6:	68a1      	ldr	r1, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000bf8:	69a3      	ldr	r3, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000bfa:	1e4a      	subs	r2, r1, #1
 8000bfc:	60a2      	str	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000bfe:	f813 0b01 	ldrb.w	r0, [r3], #1
 8000c02:	9901      	ldr	r1, [sp, #4]
 8000c04:	f801 0008 	strb.w	r0, [r1, r8]
    if (iqp->q_rdptr >= iqp->q_top) {
 8000c08:	6922      	ldr	r2, [r4, #16]
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8000c0a:	61a3      	str	r3, [r4, #24]
    if (iqp->q_rdptr >= iqp->q_top) {
 8000c0c:	4293      	cmp	r3, r2
      iqp->q_rdptr = iqp->q_buffer;
 8000c0e:	bf24      	itt	cs
 8000c10:	68e3      	ldrcs	r3, [r4, #12]
 8000c12:	61a3      	strcs	r3, [r4, #24]
 8000c14:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8000c18:	f108 0801 	add.w	r8, r8, #1
    if (--n == 0U) {
 8000c1c:	45a8      	cmp	r8, r5
 8000c1e:	d0e6      	beq.n	8000bee <chIQReadTimeout+0x3e>
 8000c20:	f38b 8811 	msr	BASEPRI, fp
 8000c24:	e7d4      	b.n	8000bd0 <chIQReadTimeout+0x20>
 8000c26:	bf00      	nop
 8000c28:	f3af 8000 	nop.w
 8000c2c:	f3af 8000 	nop.w

08000c30 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8000c30:	b410      	push	{r4}
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8000c32:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
 8000c34:	9b01      	ldr	r3, [sp, #4]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8000c36:	188c      	adds	r4, r1, r2
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000c38:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000c3a:	6040      	str	r0, [r0, #4]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000c3c:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
 8000c3e:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 8000c40:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 8000c42:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
 8000c44:	6104      	str	r4, [r0, #16]
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8000c46:	6203      	str	r3, [r0, #32]
}
 8000c48:	bc10      	pop	{r4}
 8000c4a:	4770      	bx	lr
 8000c4c:	f3af 8000 	nop.w

08000c50 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8000c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000c52:	4604      	mov	r4, r0
 8000c54:	460d      	mov	r5, r1
 8000c56:	4617      	mov	r7, r2
 8000c58:	2320      	movs	r3, #32
 8000c5a:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8000c5e:	68a6      	ldr	r6, [r4, #8]

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000c60:	4620      	mov	r0, r4
 8000c62:	4639      	mov	r1, r7
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8000c64:	b936      	cbnz	r6, 8000c74 <chOQPutTimeout+0x24>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000c66:	f7ff fe9b 	bl	80009a0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000c6a:	2800      	cmp	r0, #0
 8000c6c:	daf7      	bge.n	8000c5e <chOQPutTimeout+0xe>
 8000c6e:	f386 8811 	msr	BASEPRI, r6
      chSysUnlock();
      return msg;
 8000c72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
  }

  oqp->q_counter--;
 8000c74:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000c76:	6960      	ldr	r0, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000c78:	1e59      	subs	r1, r3, #1
 8000c7a:	60a1      	str	r1, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000c7c:	f800 5b01 	strb.w	r5, [r0], #1
  if (oqp->q_wrptr >= oqp->q_top) {
 8000c80:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000c82:	6160      	str	r0, [r4, #20]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000c84:	4290      	cmp	r0, r2
    oqp->q_wrptr = oqp->q_buffer;
 8000c86:	bf28      	it	cs
 8000c88:	68e0      	ldrcs	r0, [r4, #12]
  }

  if (oqp->q_notify != NULL) {
 8000c8a:	69e3      	ldr	r3, [r4, #28]
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
  if (oqp->q_wrptr >= oqp->q_top) {
    oqp->q_wrptr = oqp->q_buffer;
 8000c8c:	bf28      	it	cs
 8000c8e:	6160      	strcs	r0, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8000c90:	b10b      	cbz	r3, 8000c96 <chOQPutTimeout+0x46>
    oqp->q_notify(oqp);
 8000c92:	4620      	mov	r0, r4
 8000c94:	4798      	blx	r3
 8000c96:	2000      	movs	r0, #0
 8000c98:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8000c9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c9e:	bf00      	nop

08000ca0 <chOQGetI>:
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000ca0:	6983      	ldr	r3, [r0, #24]
 8000ca2:	6942      	ldr	r2, [r0, #20]
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8000ca4:	b510      	push	{r4, lr}
 8000ca6:	429a      	cmp	r2, r3
 8000ca8:	d00f      	beq.n	8000cca <chOQGetI+0x2a>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000caa:	6881      	ldr	r1, [r0, #8]
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8000cac:	6902      	ldr	r2, [r0, #16]

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000cae:	1c4c      	adds	r4, r1, #1
 8000cb0:	6084      	str	r4, [r0, #8]
  b = *oqp->q_rdptr++;
 8000cb2:	f813 4b01 	ldrb.w	r4, [r3], #1
  if (oqp->q_rdptr >= oqp->q_top) {
 8000cb6:	4293      	cmp	r3, r2
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8000cb8:	6183      	str	r3, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 8000cba:	d301      	bcc.n	8000cc0 <chOQGetI+0x20>
    oqp->q_rdptr = oqp->q_buffer;
 8000cbc:	68c3      	ldr	r3, [r0, #12]
 8000cbe:	6183      	str	r3, [r0, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8000cc0:	2100      	movs	r1, #0
 8000cc2:	f7ff fe85 	bl	80009d0 <chThdDequeueNextI>

  return (msg_t)b;
 8000cc6:	4620      	mov	r0, r4
 8000cc8:	bd10      	pop	{r4, pc}
 8000cca:	6881      	ldr	r1, [r0, #8]
 8000ccc:	2900      	cmp	r1, #0
 8000cce:	d0ec      	beq.n	8000caa <chOQGetI+0xa>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 8000cd0:	f06f 0002 	mvn.w	r0, #2
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);

  return (msg_t)b;
}
 8000cd4:	bd10      	pop	{r4, pc}
 8000cd6:	bf00      	nop
 8000cd8:	f3af 8000 	nop.w
 8000cdc:	f3af 8000 	nop.w

08000ce0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8000ce0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000ce4:	b083      	sub	sp, #12
 8000ce6:	4604      	mov	r4, r0
 8000ce8:	460d      	mov	r5, r1
 8000cea:	4616      	mov	r6, r2
 8000cec:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8000cee:	f8d0 901c 	ldr.w	r9, [r0, #28]
 8000cf2:	f04f 0b20 	mov.w	fp, #32
 8000cf6:	f38b 8811 	msr	BASEPRI, fp
  size_t w = 0;
 8000cfa:	f04f 0800 	mov.w	r8, #0
 8000cfe:	46c2      	mov	sl, r8
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8000d00:	68a7      	ldr	r7, [r4, #8]
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8000d02:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000d04:	b1ef      	cbz	r7, 8000d42 <chOQWriteTimeout+0x62>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000d06:	68a1      	ldr	r1, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000d08:	6963      	ldr	r3, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000d0a:	1e4a      	subs	r2, r1, #1
 8000d0c:	60a2      	str	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000d0e:	7829      	ldrb	r1, [r5, #0]
 8000d10:	f803 1b01 	strb.w	r1, [r3], #1
    if (oqp->q_wrptr >= oqp->q_top) {
 8000d14:	6922      	ldr	r2, [r4, #16]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000d16:	6163      	str	r3, [r4, #20]
    if (oqp->q_wrptr >= oqp->q_top) {
 8000d18:	4293      	cmp	r3, r2
      oqp->q_wrptr = oqp->q_buffer;
 8000d1a:	bf24      	itt	cs
 8000d1c:	68e3      	ldrcs	r3, [r4, #12]
 8000d1e:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 8000d20:	f1b9 0f00 	cmp.w	r9, #0
 8000d24:	d000      	beq.n	8000d28 <chOQWriteTimeout+0x48>
      nfy(oqp);
 8000d26:	47c8      	blx	r9
 8000d28:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8000d2c:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 8000d2e:	f108 0801 	add.w	r8, r8, #1
    if (--n == 0U) {
 8000d32:	d00e      	beq.n	8000d52 <chOQWriteTimeout+0x72>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000d34:	3501      	adds	r5, #1
 8000d36:	f38b 8811 	msr	BASEPRI, fp
 8000d3a:	68a7      	ldr	r7, [r4, #8]
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8000d3c:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000d3e:	2f00      	cmp	r7, #0
 8000d40:	d1e1      	bne.n	8000d06 <chOQWriteTimeout+0x26>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8000d42:	4620      	mov	r0, r4
 8000d44:	9901      	ldr	r1, [sp, #4]
 8000d46:	f7ff fe2b 	bl	80009a0 <chThdEnqueueTimeoutS>
 8000d4a:	2800      	cmp	r0, #0
 8000d4c:	d0d8      	beq.n	8000d00 <chOQWriteTimeout+0x20>
 8000d4e:	f387 8811 	msr	BASEPRI, r7
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8000d52:	4640      	mov	r0, r8
 8000d54:	b003      	add	sp, #12
 8000d56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000d5a:	bf00      	nop
 8000d5c:	f3af 8000 	nop.w

08000d60 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000d60:	4909      	ldr	r1, [pc, #36]	; (8000d88 <_core_init+0x28>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000d62:	f242 0c00 	movw	ip, #8192	; 0x2000
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000d66:	f640 1254 	movw	r2, #2388	; 0x954
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000d6a:	f640 1350 	movw	r3, #2384	; 0x950
 8000d6e:	f2c2 0c00 	movt	ip, #8192	; 0x2000
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000d72:	f021 0007 	bic.w	r0, r1, #7
 8000d76:	f2c2 0200 	movt	r2, #8192	; 0x2000
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000d7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000d7e:	f02c 0107 	bic.w	r1, ip, #7
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000d82:	6010      	str	r0, [r2, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000d84:	6019      	str	r1, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 8000d86:	4770      	bx	lr
 8000d88:	20000bb7 	.word	0x20000bb7
 8000d8c:	f3af 8000 	nop.w

08000d90 <chCoreAlloc>:
 8000d90:	2220      	movs	r2, #32
 8000d92:	f382 8811 	msr	BASEPRI, r2

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000d96:	f640 1c54 	movw	ip, #2388	; 0x954
 8000d9a:	f640 1150 	movw	r1, #2384	; 0x950
 8000d9e:	f2c2 0c00 	movt	ip, #8192	; 0x2000
 8000da2:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000da6:	f8dc 2000 	ldr.w	r2, [ip]
 8000daa:	680b      	ldr	r3, [r1, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000dac:	3007      	adds	r0, #7
 8000dae:	f020 0007 	bic.w	r0, r0, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000db2:	1a99      	subs	r1, r3, r2
 8000db4:	4288      	cmp	r0, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8000db6:	bf9a      	itte	ls
 8000db8:	1810      	addls	r0, r2, r0
 8000dba:	f8cc 0000 	strls.w	r0, [ip]

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 8000dbe:	2200      	movhi	r2, #0
 8000dc0:	2300      	movs	r3, #0
 8000dc2:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 8000dc6:	4610      	mov	r0, r2
 8000dc8:	4770      	bx	lr
 8000dca:	bf00      	nop
 8000dcc:	f3af 8000 	nop.w

08000dd0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8000dd0:	f640 1358 	movw	r3, #2392	; 0x958
 8000dd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000dd8:	f640 5291 	movw	r2, #3473	; 0xd91
  default_heap.h_free.h.u.next = NULL;
 8000ddc:	2100      	movs	r1, #0
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8000dde:	f6c0 0200 	movt	r2, #2048	; 0x800
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8000de2:	f103 0010 	add.w	r0, r3, #16
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8000de6:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8000de8:	6099      	str	r1, [r3, #8]
  default_heap.h_free.h.size = 0;
 8000dea:	60d9      	str	r1, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8000dec:	f7ff be50 	b.w	8000a90 <chMtxObjectInit>

08000df0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000df0:	f3ef 8009 	mrs	r0, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000df4:	3020      	adds	r0, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000df6:	f380 8809 	msr	PSP, r0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000dfa:	2300      	movs	r3, #0
 8000dfc:	f383 8811 	msr	BASEPRI, r3
  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 8000e00:	4770      	bx	lr
 8000e02:	bf00      	nop
 8000e04:	f3af 8000 	nop.w
 8000e08:	f3af 8000 	nop.w
 8000e0c:	f3af 8000 	nop.w

08000e10 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8000e10:	b510      	push	{r4, lr}
 8000e12:	2120      	movs	r1, #32
 8000e14:	f381 8811 	msr	BASEPRI, r1

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000e18:	f44f 406d 	mov.w	r0, #60672	; 0xed00
 8000e1c:	f2ce 0000 	movt	r0, #57344	; 0xe000
 8000e20:	6843      	ldr	r3, [r0, #4]
 8000e22:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8000e26:	d102      	bne.n	8000e2e <_port_irq_epilogue+0x1e>
 8000e28:	f383 8811 	msr	BASEPRI, r3
 8000e2c:	bd10      	pop	{r4, pc}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e2e:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000e32:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000e36:	f844 3c04 	str.w	r3, [r4, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000e3a:	f1a4 0220 	sub.w	r2, r4, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000e3e:	f382 8809 	msr	PSP, r2
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000e42:	f7ff fcc5 	bl	80007d0 <chSchIsPreemptionRequired>
 8000e46:	b130      	cbz	r0, 8000e56 <_port_irq_epilogue+0x46>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000e48:	f240 2081 	movw	r0, #641	; 0x281
 8000e4c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000e50:	f844 0c08 	str.w	r0, [r4, #-8]
 8000e54:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000e56:	f240 2184 	movw	r1, #644	; 0x284
 8000e5a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000e5e:	f844 1c08 	str.w	r1, [r4, #-8]
 8000e62:	bd10      	pop	{r4, pc}
 8000e64:	f3af 8000 	nop.w
 8000e68:	f3af 8000 	nop.w
 8000e6c:	f3af 8000 	nop.w

08000e70 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000e70:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8000e72:	f000 f8ed 	bl	8001050 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8000e76:	f641 3060 	movw	r0, #7008	; 0x1b60
 8000e7a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000e7e:	f000 f99f 	bl	80011c0 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000e82:	f000 f86d 	bl	8000f60 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000e86:	f000 fb33 	bl	80014f0 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8000e8a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8000e8e:	f000 b807 	b.w	8000ea0 <stInit>
 8000e92:	bf00      	nop
 8000e94:	f3af 8000 	nop.w
 8000e98:	f3af 8000 	nop.w
 8000e9c:	f3af 8000 	nop.w

08000ea0 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8000ea0:	f000 b966 	b.w	8001170 <st_lld_init>
 8000ea4:	f3af 8000 	nop.w
 8000ea8:	f3af 8000 	nop.w
 8000eac:	f3af 8000 	nop.w

08000eb0 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000eb0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000eb4:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000eb6:	2202      	movs	r2, #2
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
 8000eb8:	2000      	movs	r0, #0
 8000eba:	6118      	str	r0, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000ebc:	60da      	str	r2, [r3, #12]
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
 8000ebe:	4770      	bx	lr

08000ec0 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000ec0:	2200      	movs	r2, #0
 8000ec2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000ec6:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 8000ec8:	4770      	bx	lr
 8000eca:	bf00      	nop
 8000ecc:	f3af 8000 	nop.w

08000ed0 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000ed0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000ed4:	6358      	str	r0, [r3, #52]	; 0x34
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
 8000ed6:	4770      	bx	lr
 8000ed8:	f3af 8000 	nop.w
 8000edc:	f3af 8000 	nop.w

08000ee0 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000ee0:	300c      	adds	r0, #12
 8000ee2:	f7ff be65 	b.w	8000bb0 <chIQReadTimeout>
 8000ee6:	bf00      	nop
 8000ee8:	f3af 8000 	nop.w
 8000eec:	f3af 8000 	nop.w

08000ef0 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000ef0:	300c      	adds	r0, #12
 8000ef2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000ef6:	f7ff be5b 	b.w	8000bb0 <chIQReadTimeout>
 8000efa:	bf00      	nop
 8000efc:	f3af 8000 	nop.w

08000f00 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000f00:	3030      	adds	r0, #48	; 0x30
 8000f02:	f7ff beed 	b.w	8000ce0 <chOQWriteTimeout>
 8000f06:	bf00      	nop
 8000f08:	f3af 8000 	nop.w
 8000f0c:	f3af 8000 	nop.w

08000f10 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000f10:	3030      	adds	r0, #48	; 0x30
 8000f12:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000f16:	f7ff bee3 	b.w	8000ce0 <chOQWriteTimeout>
 8000f1a:	bf00      	nop
 8000f1c:	f3af 8000 	nop.w

08000f20 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000f20:	300c      	adds	r0, #12
 8000f22:	f7ff be1d 	b.w	8000b60 <chIQGetTimeout>
 8000f26:	bf00      	nop
 8000f28:	f3af 8000 	nop.w
 8000f2c:	f3af 8000 	nop.w

08000f30 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000f30:	300c      	adds	r0, #12
 8000f32:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8000f36:	f7ff be13 	b.w	8000b60 <chIQGetTimeout>
 8000f3a:	bf00      	nop
 8000f3c:	f3af 8000 	nop.w

08000f40 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000f40:	3030      	adds	r0, #48	; 0x30
 8000f42:	f7ff be85 	b.w	8000c50 <chOQPutTimeout>
 8000f46:	bf00      	nop
 8000f48:	f3af 8000 	nop.w
 8000f4c:	f3af 8000 	nop.w

08000f50 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000f50:	3030      	adds	r0, #48	; 0x30
 8000f52:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000f56:	f7ff be7b 	b.w	8000c50 <chOQPutTimeout>
 8000f5a:	bf00      	nop
 8000f5c:	f3af 8000 	nop.w

08000f60 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8000f60:	f000 ba3e 	b.w	80013e0 <sd_lld_init>
 8000f64:	f3af 8000 	nop.w
 8000f68:	f3af 8000 	nop.w
 8000f6c:	f3af 8000 	nop.w

08000f70 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000f70:	b570      	push	{r4, r5, r6, lr}
 8000f72:	4604      	mov	r4, r0

  sdp->vmt = &vmt;
 8000f74:	f641 3030 	movw	r0, #6960	; 0x1b30
 8000f78:	4626      	mov	r6, r4
 8000f7a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000f7e:	f846 0b04 	str.w	r0, [r6], #4
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8000f82:	6066      	str	r6, [r4, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000f84:	2601      	movs	r6, #1
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000f86:	b082      	sub	sp, #8
 8000f88:	460b      	mov	r3, r1
 8000f8a:	4615      	mov	r5, r2

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000f8c:	f104 000c 	add.w	r0, r4, #12
 8000f90:	f104 0154 	add.w	r1, r4, #84	; 0x54
 8000f94:	2210      	movs	r2, #16
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000f96:	7226      	strb	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000f98:	9400      	str	r4, [sp, #0]
 8000f9a:	f7ff fdb1 	bl	8000b00 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8000f9e:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8000fa2:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8000fa6:	2210      	movs	r2, #16
 8000fa8:	462b      	mov	r3, r5
 8000faa:	9400      	str	r4, [sp, #0]
 8000fac:	f7ff fe40 	bl	8000c30 <chOQObjectInit>
}
 8000fb0:	b002      	add	sp, #8
 8000fb2:	bd70      	pop	{r4, r5, r6, pc}
 8000fb4:	f3af 8000 	nop.w
 8000fb8:	f3af 8000 	nop.w
 8000fbc:	f3af 8000 	nop.w

08000fc0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8000fc0:	b510      	push	{r4, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000fc2:	2220      	movs	r2, #32
 8000fc4:	4604      	mov	r4, r0
 8000fc6:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 8000fca:	f000 fa31 	bl	8001430 <sd_lld_start>
  sdp->state = SD_READY;
 8000fce:	2002      	movs	r0, #2
 8000fd0:	7220      	strb	r0, [r4, #8]
 8000fd2:	2300      	movs	r3, #0
 8000fd4:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 8000fd8:	bd10      	pop	{r4, pc}
 8000fda:	bf00      	nop
 8000fdc:	f3af 8000 	nop.w

08000fe0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000fe0:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8000fe2:	6943      	ldr	r3, [r0, #20]
 8000fe4:	4604      	mov	r4, r0
 8000fe6:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000fe8:	b13b      	cbz	r3, 8000ffa <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8000fea:	f104 000c 	add.w	r0, r4, #12
 8000fee:	4629      	mov	r1, r5
 8000ff0:	f7ff fd96 	bl	8000b20 <chIQPutI>
 8000ff4:	2800      	cmp	r0, #0
 8000ff6:	db0b      	blt.n	8001010 <sdIncomingDataI+0x30>
 8000ff8:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000ffa:	3004      	adds	r0, #4
 8000ffc:	2104      	movs	r1, #4
 8000ffe:	f7ff fd67 	bl	8000ad0 <chEvtBroadcastFlagsI>
 8001002:	f104 000c 	add.w	r0, r4, #12
 8001006:	4629      	mov	r1, r5
 8001008:	f7ff fd8a 	bl	8000b20 <chIQPutI>
 800100c:	2800      	cmp	r0, #0
 800100e:	daf3      	bge.n	8000ff8 <sdIncomingDataI+0x18>
 8001010:	1d20      	adds	r0, r4, #4
 8001012:	2180      	movs	r1, #128	; 0x80
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 8001014:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001018:	f7ff bd5a 	b.w	8000ad0 <chEvtBroadcastFlagsI>
 800101c:	f3af 8000 	nop.w

08001020 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8001020:	b430      	push	{r4, r5}
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001022:	f000 051f 	and.w	r5, r0, #31
 8001026:	2401      	movs	r4, #1
 8001028:	40ac      	lsls	r4, r5

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800102a:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800102e:	f2ce 0300 	movt	r3, #57344	; 0xe000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001032:	0942      	lsrs	r2, r0, #5

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001034:	0109      	lsls	r1, r1, #4
 8001036:	1818      	adds	r0, r3, r0
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001038:	f102 0560 	add.w	r5, r2, #96	; 0x60

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800103c:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001040:	f843 4025 	str.w	r4, [r3, r5, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001044:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
}
 8001048:	bc30      	pop	{r4, r5}
 800104a:	4770      	bx	lr
 800104c:	f3af 8000 	nop.w

08001050 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 8001050:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
 8001054:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8001058:	f04f 33ff 	mov.w	r3, #4294967295
 800105c:	2200      	movs	r2, #0
 800105e:	f8dc 0010 	ldr.w	r0, [ip, #16]
 8001062:	f8cc 3010 	str.w	r3, [ip, #16]
 8001066:	f8cc 2010 	str.w	r2, [ip, #16]
  rccResetAPB2(0xFFFFFFFF);
 800106a:	f8dc 000c 	ldr.w	r0, [ip, #12]
 800106e:	f8cc 300c 	str.w	r3, [ip, #12]
 8001072:	f8cc 200c 	str.w	r2, [ip, #12]

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 8001076:	f8dc 101c 	ldr.w	r1, [ip, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800107a:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 800107e:	f041 5080 	orr.w	r0, r1, #268435456	; 0x10000000
 8001082:	f8cc 001c 	str.w	r0, [ip, #28]
  rccEnableBKPInterface(FALSE);
 8001086:	f8dc 301c 	ldr.w	r3, [ip, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800108a:	f2c4 0200 	movt	r2, #16384	; 0x4000
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
  rccEnableBKPInterface(FALSE);
 800108e:	f043 6100 	orr.w	r1, r3, #134217728	; 0x8000000
 8001092:	f8cc 101c 	str.w	r1, [ip, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001096:	6810      	ldr	r0, [r2, #0]
 8001098:	f440 7380 	orr.w	r3, r0, #256	; 0x100
 800109c:	6013      	str	r3, [r2, #0]

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800109e:	4770      	bx	lr

080010a0 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80010a0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010a4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010a8:	6818      	ldr	r0, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80010aa:	4619      	mov	r1, r3
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80010ac:	f040 0201 	orr.w	r2, r0, #1
 80010b0:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80010b2:	680a      	ldr	r2, [r1, #0]
 80010b4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010b8:	0792      	lsls	r2, r2, #30
 80010ba:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010be:	d5f8      	bpl.n	80010b2 <stm32_clock_init+0x12>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80010c0:	681a      	ldr	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80010c2:	2000      	movs	r0, #0
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80010c4:	f002 01f9 	and.w	r1, r2, #249	; 0xf9
 80010c8:	6019      	str	r1, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80010ca:	4619      	mov	r1, r3
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80010cc:	6058      	str	r0, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80010ce:	6848      	ldr	r0, [r1, #4]
 80010d0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010d4:	f010 0f0c 	tst.w	r0, #12
 80010d8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010dc:	d1f7      	bne.n	80010ce <stm32_clock_init+0x2e>
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 80010de:	6818      	ldr	r0, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 80010e0:	4619      	mov	r1, r3
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 80010e2:	f440 3280 	orr.w	r2, r0, #65536	; 0x10000
 80010e6:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 80010e8:	680a      	ldr	r2, [r1, #0]
 80010ea:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010ee:	0390      	lsls	r0, r2, #14
 80010f0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010f4:	d5f8      	bpl.n	80010e8 <stm32_clock_init+0x48>
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 80010f6:	685a      	ldr	r2, [r3, #4]
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80010f8:	4619      	mov	r1, r3
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 80010fa:	f442 3080 	orr.w	r0, r2, #65536	; 0x10000
 80010fe:	6058      	str	r0, [r3, #4]
  RCC->CR   |= RCC_CR_PLLON;
 8001100:	681a      	ldr	r2, [r3, #0]
 8001102:	f042 7080 	orr.w	r0, r2, #16777216	; 0x1000000
 8001106:	6018      	str	r0, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001108:	6808      	ldr	r0, [r1, #0]
 800110a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800110e:	0182      	lsls	r2, r0, #6
 8001110:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001114:	d5f8      	bpl.n	8001108 <stm32_clock_init+0x68>
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001116:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#else
  RCC->CFGR = STM32_MCOSEL |                STM32_PLLMUL | STM32_PLLXTPRE |
 800111a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800111e:	2110      	movs	r1, #16
 8001120:	f2c4 0c02 	movt	ip, #16386	; 0x4002
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#else
  RCC->CFGR = STM32_MCOSEL |                STM32_PLLMUL | STM32_PLLXTPRE |
 8001124:	605a      	str	r2, [r3, #4]
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001126:	f8cc 1000 	str.w	r1, [ip]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800112a:	6858      	ldr	r0, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800112c:	461a      	mov	r2, r3
  FLASH->ACR = STM32_FLASHBITS;

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800112e:	f040 0102 	orr.w	r1, r0, #2
 8001132:	6059      	str	r1, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001134:	6850      	ldr	r0, [r2, #4]
 8001136:	f000 030c 	and.w	r3, r0, #12
 800113a:	2b08      	cmp	r3, #8
 800113c:	d1fa      	bne.n	8001134 <stm32_clock_init+0x94>

#if !STM32_HSI_ENABLED
  RCC->CR &= ~RCC_CR_HSION;
#endif
#endif /* !STM32_NO_INIT */
}
 800113e:	4770      	bx	lr

08001140 <VectorB0>:
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001140:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001144:	691a      	ldr	r2, [r3, #16]
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001146:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001148:	0792      	lsls	r2, r2, #30
 800114a:	d508      	bpl.n	800115e <VectorB0+0x1e>
    STM32_ST_TIM->SR = 0U;
 800114c:	2400      	movs	r4, #0
 800114e:	611c      	str	r4, [r3, #16]
 8001150:	2320      	movs	r3, #32
 8001152:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 8001156:	f7ff f97b 	bl	8000450 <chSysTimerHandlerI>
 800115a:	f384 8811 	msr	BASEPRI, r4
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 800115e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8001162:	f7ff be55 	b.w	8000e10 <_port_irq_epilogue>
 8001166:	bf00      	nop
 8001168:	f3af 8000 	nop.w
 800116c:	f3af 8000 	nop.w

08001170 <st_lld_init>:

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001170:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
 8001174:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8001178:	f8dc 301c 	ldr.w	r3, [ip, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800117c:	f44f 5000 	mov.w	r0, #8192	; 0x2000

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001180:	f043 0201 	orr.w	r2, r3, #1
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8001184:	b430      	push	{r4, r5}

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001186:	f2ce 0004 	movt	r0, #57348	; 0xe004

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800118a:	f8cc 201c 	str.w	r2, [ip, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800118e:	6844      	ldr	r4, [r0, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001190:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001194:	f444 6100 	orr.w	r1, r4, #2048	; 0x800

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001198:	f645 55bf 	movw	r5, #23999	; 0x5dbf

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800119c:	6041      	str	r1, [r0, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 800119e:	2200      	movs	r2, #0

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80011a0:	629d      	str	r5, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80011a2:	2401      	movs	r4, #1
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80011a4:	f64f 75ff 	movw	r5, #65535	; 0xffff
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80011a8:	201c      	movs	r0, #28
 80011aa:	2108      	movs	r1, #8
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80011ac:	62dd      	str	r5, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80011ae:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80011b0:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80011b2:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80011b4:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80011b6:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80011b8:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80011ba:	bc30      	pop	{r4, r5}
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80011bc:	f7ff bf30 	b.w	8001020 <nvicEnableVector>

080011c0 <_pal_lld_init>:
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 80011c0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80011c4:	f2c4 0102 	movt	r1, #16386	; 0x4002
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 80011c8:	b410      	push	{r4}

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 80011ca:	698c      	ldr	r4, [r1, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 80011cc:	f44f 6c00 	mov.w	ip, #2048	; 0x800
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 80011d0:	f044 027d 	orr.w	r2, r4, #125	; 0x7d
 80011d4:	618a      	str	r2, [r1, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 80011d6:	6803      	ldr	r3, [r0, #0]
 80011d8:	f2c4 0c01 	movt	ip, #16385	; 0x4001
 80011dc:	f8cc 300c 	str.w	r3, [ip, #12]
  GPIOA->CRH = config->PAData.crh;
 80011e0:	6884      	ldr	r4, [r0, #8]
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 80011e2:	f44f 6340 	mov.w	r3, #3072	; 0xc00

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
 80011e6:	f8cc 4004 	str.w	r4, [ip, #4]
  GPIOA->CRL = config->PAData.crl;
 80011ea:	6841      	ldr	r1, [r0, #4]
  GPIOB->ODR = config->PBData.odr;
 80011ec:	f2c4 0301 	movt	r3, #16385	; 0x4001
  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
 80011f0:	f8cc 1000 	str.w	r1, [ip]
  GPIOB->ODR = config->PBData.odr;
 80011f4:	68c2      	ldr	r2, [r0, #12]
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 80011f6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 80011fa:	60da      	str	r2, [r3, #12]
  GPIOB->CRH = config->PBData.crh;
 80011fc:	6944      	ldr	r4, [r0, #20]
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 80011fe:	f2c4 0101 	movt	r1, #16385	; 0x4001
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
 8001202:	605c      	str	r4, [r3, #4]
  GPIOB->CRL = config->PBData.crl;
 8001204:	6902      	ldr	r2, [r0, #16]
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 8001206:	f44f 5ca0 	mov.w	ip, #5120	; 0x1400
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
 800120a:	601a      	str	r2, [r3, #0]
  GPIOC->ODR = config->PCData.odr;
 800120c:	6983      	ldr	r3, [r0, #24]
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 800120e:	f2c4 0c01 	movt	ip, #16385	; 0x4001
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 8001212:	60cb      	str	r3, [r1, #12]
  GPIOC->CRH = config->PCData.crh;
 8001214:	6a04      	ldr	r4, [r0, #32]
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8001216:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
 800121a:	604c      	str	r4, [r1, #4]
  GPIOC->CRL = config->PCData.crl;
 800121c:	69c4      	ldr	r4, [r0, #28]
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 800121e:	f2c4 0301 	movt	r3, #16385	; 0x4001
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
 8001222:	600c      	str	r4, [r1, #0]
  GPIOD->ODR = config->PDData.odr;
 8001224:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8001226:	f8cc 100c 	str.w	r1, [ip, #12]
  GPIOD->CRH = config->PDData.crh;
 800122a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 800122c:	f8cc 2004 	str.w	r2, [ip, #4]
  GPIOD->CRL = config->PDData.crl;
 8001230:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8001232:	f8cc 1000 	str.w	r1, [ip]
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8001236:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8001238:	60da      	str	r2, [r3, #12]
  GPIOE->CRH = config->PEData.crh;
 800123a:	6b81      	ldr	r1, [r0, #56]	; 0x38
 800123c:	6059      	str	r1, [r3, #4]
  GPIOE->CRL = config->PEData.crl;
 800123e:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8001240:	601a      	str	r2, [r3, #0]
  GPIOG->CRH = config->PGData.crh;
  GPIOG->CRL = config->PGData.crl;
#endif
#endif
#endif
}
 8001242:	bc10      	pop	{r4}
 8001244:	4770      	bx	lr
 8001246:	bf00      	nop
 8001248:	f3af 8000 	nop.w
 800124c:	f3af 8000 	nop.w

08001250 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8001250:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8001254:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001258:	68d8      	ldr	r0, [r3, #12]
 800125a:	f040 0280 	orr.w	r2, r0, #128	; 0x80
 800125e:	60da      	str	r2, [r3, #12]
}
 8001260:	4770      	bx	lr
 8001262:	bf00      	nop
 8001264:	f3af 8000 	nop.w
 8001268:	f3af 8000 	nop.w
 800126c:	f3af 8000 	nop.w

08001270 <notify3>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
 8001270:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8001274:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001278:	68d8      	ldr	r0, [r3, #12]
 800127a:	f040 0280 	orr.w	r2, r0, #128	; 0x80
 800127e:	60da      	str	r2, [r3, #12]
}
 8001280:	4770      	bx	lr
 8001282:	bf00      	nop
 8001284:	f3af 8000 	nop.w
 8001288:	f3af 8000 	nop.w
 800128c:	f3af 8000 	nop.w

08001290 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8001290:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  USART_TypeDef *u = sdp->usart;
 8001294:	6f45      	ldr	r5, [r0, #116]	; 0x74
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8001296:	4606      	mov	r6, r0
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
 8001298:	68eb      	ldr	r3, [r5, #12]
  uint16_t sr = u->SR;
 800129a:	682c      	ldr	r4, [r5, #0]
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
 800129c:	fa1f f883 	uxth.w	r8, r3
  uint16_t sr = u->SR;
 80012a0:	b2a4      	uxth	r4, r4

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 80012a2:	05e2      	lsls	r2, r4, #23
 80012a4:	d449      	bmi.n	800133a <serve_interrupt+0xaa>
 80012a6:	2320      	movs	r3, #32
 80012a8:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80012ac:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80012b0:	d027      	beq.n	8001302 <serve_interrupt+0x72>
    sts |= SD_PARITY_ERROR;
  if (sr & USART_SR_FE)
    sts |= SD_FRAMING_ERROR;
  if (sr & USART_SR_NE)
    sts |= SD_NOISE_ERROR;
  chnAddFlagsI(sdp, sts);
 80012b2:	1d37      	adds	r7, r6, #4
 80012b4:	e004      	b.n	80012c0 <serve_interrupt+0x30>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 80012b6:	682c      	ldr	r4, [r5, #0]
 80012b8:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80012ba:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80012be:	d020      	beq.n	8001302 <serve_interrupt+0x72>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80012c0:	0723      	lsls	r3, r4, #28
 80012c2:	d012      	beq.n	80012ea <serve_interrupt+0x5a>
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
 80012c4:	f014 0108 	ands.w	r1, r4, #8
    sts |= SD_OVERRUN_ERROR;
 80012c8:	bf18      	it	ne
 80012ca:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 80012cc:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 80012ce:	bf48      	it	mi
 80012d0:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 80012d4:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 80012d6:	bf48      	it	mi
 80012d8:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 80012dc:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 80012de:	bf48      	it	mi
 80012e0:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80012e4:	4638      	mov	r0, r7
 80012e6:	f7ff fbf3 	bl	8000ad0 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 80012ea:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 80012ec:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 80012ee:	d5e2      	bpl.n	80012b6 <serve_interrupt+0x26>
      sdIncomingDataI(sdp, b);
 80012f0:	4630      	mov	r0, r6
 80012f2:	b2c9      	uxtb	r1, r1
 80012f4:	f7ff fe74 	bl	8000fe0 <sdIncomingDataI>
    sr = u->SR;
 80012f8:	682c      	ldr	r4, [r5, #0]
 80012fa:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80012fc:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001300:	d1de      	bne.n	80012c0 <serve_interrupt+0x30>
 8001302:	2000      	movs	r0, #0
 8001304:	f380 8811 	msr	BASEPRI, r0
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8001308:	f018 0f80 	tst.w	r8, #128	; 0x80
 800130c:	d001      	beq.n	8001312 <serve_interrupt+0x82>
 800130e:	0622      	lsls	r2, r4, #24
 8001310:	d422      	bmi.n	8001358 <serve_interrupt+0xc8>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8001312:	0663      	lsls	r3, r4, #25
 8001314:	d50f      	bpl.n	8001336 <serve_interrupt+0xa6>
 8001316:	2220      	movs	r2, #32
 8001318:	f382 8811 	msr	BASEPRI, r2
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800131c:	6c70      	ldr	r0, [r6, #68]	; 0x44
 800131e:	6cb1      	ldr	r1, [r6, #72]	; 0x48
 8001320:	4288      	cmp	r0, r1
 8001322:	d028      	beq.n	8001376 <serve_interrupt+0xe6>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001324:	f028 0240 	bic.w	r2, r8, #64	; 0x40
    u->SR = ~USART_SR_TC;
 8001328:	f06f 0140 	mvn.w	r1, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800132c:	60ea      	str	r2, [r5, #12]
 800132e:	2000      	movs	r0, #0
    u->SR = ~USART_SR_TC;
 8001330:	6029      	str	r1, [r5, #0]
 8001332:	f380 8811 	msr	BASEPRI, r0
 8001336:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800133a:	2220      	movs	r2, #32
 800133c:	f382 8811 	msr	BASEPRI, r2
 8001340:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001344:	3004      	adds	r0, #4
 8001346:	f7ff fbc3 	bl	8000ad0 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 800134a:	f46f 7180 	mvn.w	r1, #256	; 0x100
 800134e:	6029      	str	r1, [r5, #0]
 8001350:	2000      	movs	r0, #0
 8001352:	f380 8811 	msr	BASEPRI, r0
 8001356:	e7a6      	b.n	80012a6 <serve_interrupt+0x16>
 8001358:	2120      	movs	r1, #32
 800135a:	f381 8811 	msr	BASEPRI, r1

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 800135e:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8001362:	f7ff fc9d 	bl	8000ca0 <chOQGetI>
    if (b < Q_OK) {
 8001366:	2800      	cmp	r0, #0
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 8001368:	bfa8      	it	ge
 800136a:	6068      	strge	r0, [r5, #4]
  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
 800136c:	db0b      	blt.n	8001386 <serve_interrupt+0xf6>
 800136e:	2300      	movs	r3, #0
 8001370:	f383 8811 	msr	BASEPRI, r3
 8001374:	e7cd      	b.n	8001312 <serve_interrupt+0x82>
 8001376:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8001378:	2b00      	cmp	r3, #0
 800137a:	d0d3      	beq.n	8001324 <serve_interrupt+0x94>
 800137c:	1d30      	adds	r0, r6, #4
 800137e:	2110      	movs	r1, #16
 8001380:	f7ff fba6 	bl	8000ad0 <chEvtBroadcastFlagsI>
 8001384:	e7ce      	b.n	8001324 <serve_interrupt+0x94>
 8001386:	1d30      	adds	r0, r6, #4
 8001388:	2108      	movs	r1, #8
 800138a:	f7ff fba1 	bl	8000ad0 <chEvtBroadcastFlagsI>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800138e:	f028 0cc0 	bic.w	ip, r8, #192	; 0xc0
 8001392:	f04c 0240 	orr.w	r2, ip, #64	; 0x40
 8001396:	60ea      	str	r2, [r5, #12]
 8001398:	e7e9      	b.n	800136e <serve_interrupt+0xde>
 800139a:	bf00      	nop
 800139c:	f3af 8000 	nop.w

080013a0 <VectorD8>:
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
 80013a0:	f640 1078 	movw	r0, #2424	; 0x978
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 80013a4:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
 80013a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80013aa:	f7ff ff71 	bl	8001290 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 80013ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 80013b2:	f7ff bd2d 	b.w	8000e10 <_port_irq_epilogue>
 80013b6:	bf00      	nop
 80013b8:	f3af 8000 	nop.w
 80013bc:	f3af 8000 	nop.w

080013c0 <VectorDC>:
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);
 80013c0:	f640 10f0 	movw	r0, #2544	; 0x9f0
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 80013c4:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);
 80013c6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80013ca:	f7ff ff61 	bl	8001290 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 80013ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 80013d2:	f7ff bd1d 	b.w	8000e10 <_port_irq_epilogue>
 80013d6:	bf00      	nop
 80013d8:	f3af 8000 	nop.w
 80013dc:	f3af 8000 	nop.w

080013e0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 80013e0:	b538      	push	{r3, r4, r5, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 80013e2:	f640 1578 	movw	r5, #2424	; 0x978
 80013e6:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80013ea:	f241 2251 	movw	r2, #4689	; 0x1251
 80013ee:	4628      	mov	r0, r5
 80013f0:	2100      	movs	r1, #0
 80013f2:	f6c0 0200 	movt	r2, #2048	; 0x800
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 80013f6:	f640 14f0 	movw	r4, #2544	; 0x9f0
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 80013fa:	f7ff fdb9 	bl	8000f70 <sdObjectInit>
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 80013fe:	f2c2 0400 	movt	r4, #8192	; 0x2000
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8001402:	f44f 4388 	mov.w	r3, #17408	; 0x4400
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 8001406:	f241 2271 	movw	r2, #4721	; 0x1271
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 800140a:	f2c4 0300 	movt	r3, #16384	; 0x4000
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 800140e:	4620      	mov	r0, r4
 8001410:	2100      	movs	r1, #0
 8001412:	f6c0 0200 	movt	r2, #2048	; 0x800
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8001416:	676b      	str	r3, [r5, #116]	; 0x74
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 8001418:	f7ff fdaa 	bl	8000f70 <sdObjectInit>
  SD3.usart = USART3;
 800141c:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8001420:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001424:	6763      	str	r3, [r4, #116]	; 0x74

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
 8001426:	bd38      	pop	{r3, r4, r5, pc}
 8001428:	f3af 8000 	nop.w
 800142c:	f3af 8000 	nop.w

08001430 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8001430:	b538      	push	{r3, r4, r5, lr}

  if (config == NULL)
    config = &default_config;
 8001432:	f641 3450 	movw	r4, #6992	; 0x1b50

  if (sdp->state == SD_STOP) {
 8001436:	7a03      	ldrb	r3, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 8001438:	f6c0 0400 	movt	r4, #2048	; 0x800
 800143c:	2900      	cmp	r1, #0
 800143e:	bf18      	it	ne
 8001440:	460c      	movne	r4, r1

  if (sdp->state == SD_STOP) {
 8001442:	2b01      	cmp	r3, #1
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8001444:	4605      	mov	r5, r0

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8001446:	d020      	beq.n	800148a <sd_lld_start+0x5a>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8001448:	6821      	ldr	r1, [r4, #0]
 800144a:	f44f 5058 	mov.w	r0, #13824	; 0x3600
 800144e:	f2c0 106e 	movt	r0, #366	; 0x16e
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8001452:	6f6b      	ldr	r3, [r5, #116]	; 0x74
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8001454:	fbb0 f2f1 	udiv	r2, r0, r1

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001458:	88a0      	ldrh	r0, [r4, #4]
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800145a:	88e1      	ldrh	r1, [r4, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800145c:	f8b4 c008 	ldrh.w	ip, [r4, #8]
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8001460:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001462:	f440 5204 	orr.w	r2, r0, #8448	; 0x2100
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001466:	f041 0040 	orr.w	r0, r1, #64	; 0x40
 800146a:	b280      	uxth	r0, r0
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800146c:	f04c 0101 	orr.w	r1, ip, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001470:	f042 0c2c 	orr.w	ip, r2, #44	; 0x2c
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001474:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001476:	fa1f f28c 	uxth.w	r2, ip
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800147a:	b289      	uxth	r1, r1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 800147c:	2000      	movs	r0, #0
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800147e:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001480:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8001482:	6018      	str	r0, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8001484:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8001486:	685b      	ldr	r3, [r3, #4]
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
}
 8001488:	bd38      	pop	{r3, r4, r5, pc}
      rccEnableUSART1(FALSE);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 800148a:	f640 1178 	movw	r1, #2424	; 0x978
 800148e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8001492:	4288      	cmp	r0, r1
 8001494:	d014      	beq.n	80014c0 <sd_lld_start+0x90>
      rccEnableUSART2(FALSE);
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
 8001496:	f640 11f0 	movw	r1, #2544	; 0x9f0
 800149a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800149e:	4288      	cmp	r0, r1
 80014a0:	d1d2      	bne.n	8001448 <sd_lld_start+0x18>
      rccEnableUSART3(FALSE);
 80014a2:	f44f 5e80 	mov.w	lr, #4096	; 0x1000
 80014a6:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 80014aa:	f8de 301c 	ldr.w	r3, [lr, #28]
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
 80014ae:	2027      	movs	r0, #39	; 0x27
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
      rccEnableUSART3(FALSE);
 80014b0:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 80014b4:	f8ce 201c 	str.w	r2, [lr, #28]
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
 80014b8:	210c      	movs	r1, #12
 80014ba:	f7ff fdb1 	bl	8001020 <nvicEnableVector>
 80014be:	e7c3      	b.n	8001448 <sd_lld_start+0x18>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(FALSE);
 80014c0:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
 80014c4:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 80014c8:	f8dc 301c 	ldr.w	r3, [ip, #28]
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 80014cc:	2026      	movs	r0, #38	; 0x26
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(FALSE);
 80014ce:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 80014d2:	f8cc 201c 	str.w	r2, [ip, #28]
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 80014d6:	210c      	movs	r1, #12
 80014d8:	f7ff fda2 	bl	8001020 <nvicEnableVector>
 80014dc:	e7b4      	b.n	8001448 <sd_lld_start+0x18>
 80014de:	bf00      	nop

080014e0 <__early_init>:
 * This initialization must be performed just after stack setup and before
 * any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 80014e0:	f7ff bdde 	b.w	80010a0 <stm32_clock_init>
 80014e4:	f3af 8000 	nop.w
 80014e8:	f3af 8000 	nop.w
 80014ec:	f3af 8000 	nop.w

080014f0 <boardInit>:

	/*
		USART3 re-mapped to PC10-PC11
	*/

	AFIO -> MAPR |= AFIO_MAPR_USART3_REMAP_PARTIALREMAP;
 80014f0:	2300      	movs	r3, #0
 80014f2:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80014f6:	6858      	ldr	r0, [r3, #4]
 80014f8:	f040 0210 	orr.w	r2, r0, #16
 80014fc:	605a      	str	r2, [r3, #4]
		http://stm32.kosyak.info/doc/stm32f10x_8h_source.html ->> 02606 #define AFIO_MAPR_USART3_REMAP_PARTIALRMAP, y
		02594 ****************************** Bit definition for AFIO_MAPR register ************************
		http://stm32.kosyak.info/doc/struct_a_f_i_o___type_def.html -->> el Typedef AFIO
	*/
	
}
 80014fe:	4770      	bx	lr

08001500 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001500:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001504:	b08d      	sub	sp, #52	; 0x34
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8001506:	ac09      	add	r4, sp, #36	; 0x24
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8001508:	f10d 0725 	add.w	r7, sp, #37	; 0x25
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 800150c:	9402      	str	r4, [sp, #8]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 800150e:	9701      	str	r7, [sp, #4]
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001510:	4605      	mov	r5, r0
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8001512:	f8dd c004 	ldr.w	ip, [sp, #4]
 8001516:	9802      	ldr	r0, [sp, #8]
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
 8001518:	f641 33a0 	movw	r3, #7072	; 0x1ba0
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 800151c:	ebc0 0c0c 	rsb	ip, r0, ip
 8001520:	f8cd c01c 	str.w	ip, [sp, #28]
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 8001524:	f64c 4ccd 	movw	ip, #52429	; 0xcccd
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8001528:	2700      	movs	r7, #0
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 800152a:	f6cc 4ccc 	movt	ip, #52428	; 0xcccc
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
 800152e:	f6c0 0300 	movt	r3, #2048	; 0x800
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001532:	460c      	mov	r4, r1
 8001534:	4616      	mov	r6, r2
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8001536:	9703      	str	r7, [sp, #12]
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 8001538:	f8cd c018 	str.w	ip, [sp, #24]
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
 800153c:	9305      	str	r3, [sp, #20]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800153e:	7821      	ldrb	r1, [r4, #0]
    if (c == 0)
 8001540:	b181      	cbz	r1, 8001564 <chvprintf+0x64>
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8001542:	1c67      	adds	r7, r4, #1
    if (c == 0)
      return n;
    if (c != '%') {
 8001544:	2925      	cmp	r1, #37	; 0x25
 8001546:	d011      	beq.n	800156c <chvprintf+0x6c>
      streamPut(chp, (uint8_t)c);
 8001548:	682b      	ldr	r3, [r5, #0]
 800154a:	4628      	mov	r0, r5
 800154c:	689a      	ldr	r2, [r3, #8]
 800154e:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8001550:	463c      	mov	r4, r7
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 8001552:	f8dd c00c 	ldr.w	ip, [sp, #12]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8001556:	7821      	ldrb	r1, [r4, #0]
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 8001558:	f10c 0c01 	add.w	ip, ip, #1
 800155c:	f8cd c00c 	str.w	ip, [sp, #12]
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
    if (c == 0)
 8001560:	2900      	cmp	r1, #0
 8001562:	d1ee      	bne.n	8001542 <chvprintf+0x42>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8001564:	9803      	ldr	r0, [sp, #12]
 8001566:	b00d      	add	sp, #52	; 0x34
 8001568:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 800156c:	7863      	ldrb	r3, [r4, #1]
 800156e:	2b2d      	cmp	r3, #45	; 0x2d
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8001570:	bf18      	it	ne
 8001572:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
 8001576:	f000 8201 	beq.w	800197c <chvprintf+0x47c>
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 800157a:	2b30      	cmp	r3, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 800157c:	bf11      	iteee	ne
 800157e:	f04f 0920 	movne.w	r9, #32
    if (*fmt == '0') {
      fmt++;
 8001582:	787b      	ldrbeq	r3, [r7, #1]
      filler = '0';
 8001584:	f04f 0930 	moveq.w	r9, #48	; 0x30
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
 8001588:	3701      	addeq	r7, #1
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 800158a:	463c      	mov	r4, r7
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 800158c:	f04f 0b00 	mov.w	fp, #0
 8001590:	e007      	b.n	80015a2 <chvprintf+0xa2>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 8001592:	7832      	ldrb	r2, [r6, #0]
 8001594:	3604      	adds	r6, #4
      else
        break;
      width = width * 10 + c;
 8001596:	eb0b 008b 	add.w	r0, fp, fp, lsl #2
 800159a:	f817 3f01 	ldrb.w	r3, [r7, #1]!
 800159e:	eb02 0b40 	add.w	fp, r2, r0, lsl #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80015a2:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 80015a6:	b2ca      	uxtb	r2, r1
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 80015a8:	3401      	adds	r4, #1
      if (c >= '0' && c <= '9')
 80015aa:	2a09      	cmp	r2, #9
 80015ac:	d9f3      	bls.n	8001596 <chvprintf+0x96>
        c -= '0';
      else if (c == '*')
 80015ae:	2b2a      	cmp	r3, #42	; 0x2a
 80015b0:	d0ef      	beq.n	8001592 <chvprintf+0x92>
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
 80015b2:	2100      	movs	r1, #0
    if (c == '.') {
 80015b4:	2b2e      	cmp	r3, #46	; 0x2e
 80015b6:	f000 81cd 	beq.w	8001954 <chvprintf+0x454>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80015ba:	f1a3 026c 	sub.w	r2, r3, #108	; 0x6c
 80015be:	f1d2 0c00 	rsbs	ip, r2, #0
 80015c2:	eb4c 0702 	adc.w	r7, ip, r2
 80015c6:	2b4c      	cmp	r3, #76	; 0x4c
 80015c8:	bf08      	it	eq
 80015ca:	f047 0701 	orreq.w	r7, r7, #1
 80015ce:	b11f      	cbz	r7, 80015d8 <chvprintf+0xd8>
      is_long = TRUE;
      if (*fmt)
 80015d0:	7822      	ldrb	r2, [r4, #0]
 80015d2:	b10a      	cbz	r2, 80015d8 <chvprintf+0xd8>
        c = *fmt++;
 80015d4:	3401      	adds	r4, #1
 80015d6:	4613      	mov	r3, r2
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80015d8:	f1a3 0044 	sub.w	r0, r3, #68	; 0x44
 80015dc:	2834      	cmp	r0, #52	; 0x34
 80015de:	f200 81ae 	bhi.w	800193e <chvprintf+0x43e>
 80015e2:	e8df f010 	tbh	[pc, r0, lsl #1]
 80015e6:	0157      	.short	0x0157
 80015e8:	01ac01ac 	.word	0x01ac01ac
 80015ec:	01ac01ac 	.word	0x01ac01ac
 80015f0:	01ac0157 	.word	0x01ac0157
 80015f4:	01ac01ac 	.word	0x01ac01ac
 80015f8:	01ac01ac 	.word	0x01ac01ac
 80015fc:	01ac01b5 	.word	0x01ac01b5
 8001600:	01ac01ac 	.word	0x01ac01ac
 8001604:	01ac01ac 	.word	0x01ac01ac
 8001608:	01ac01b3 	.word	0x01ac01b3
 800160c:	011801ac 	.word	0x011801ac
 8001610:	01ac01ac 	.word	0x01ac01ac
 8001614:	01ac01ac 	.word	0x01ac01ac
 8001618:	01ac01ac 	.word	0x01ac01ac
 800161c:	01ac01ac 	.word	0x01ac01ac
 8001620:	01ac01ac 	.word	0x01ac01ac
 8001624:	0157006c 	.word	0x0157006c
 8001628:	01ac01ac 	.word	0x01ac01ac
 800162c:	01ac01ac 	.word	0x01ac01ac
 8001630:	01ac0157 	.word	0x01ac0157
 8001634:	01ac01ac 	.word	0x01ac01ac
 8001638:	01ac01ac 	.word	0x01ac01ac
 800163c:	01ac01b5 	.word	0x01ac01b5
 8001640:	01ac01ac 	.word	0x01ac01ac
 8001644:	01ac0035 	.word	0x01ac0035
 8001648:	01ac01b3 	.word	0x01ac01b3
 800164c:	011801ac 	.word	0x011801ac
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8001650:	6832      	ldr	r2, [r6, #0]
        s = "(null)";
 8001652:	f8dd 8014 	ldr.w	r8, [sp, #20]
      if (precision == 0)
        precision = 32767;
 8001656:	f647 77ff 	movw	r7, #32767	; 0x7fff
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
 800165a:	2a00      	cmp	r2, #0
 800165c:	bf18      	it	ne
 800165e:	4690      	movne	r8, r2
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8001660:	f898 3000 	ldrb.w	r3, [r8]
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8001664:	3604      	adds	r6, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
 8001666:	2900      	cmp	r1, #0
 8001668:	bf08      	it	eq
 800166a:	4639      	moveq	r1, r7
      for (p = s; *p && (--precision >= 0); p++)
 800166c:	2b00      	cmp	r3, #0
 800166e:	f000 81a2 	beq.w	80019b6 <chvprintf+0x4b6>
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001672:	eb08 0001 	add.w	r0, r8, r1
 8001676:	ea6f 0308 	mvn.w	r3, r8
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800167a:	f898 1001 	ldrb.w	r1, [r8, #1]
 800167e:	eb00 0903 	add.w	r9, r0, r3
 8001682:	f108 0301 	add.w	r3, r8, #1
 8001686:	f009 0701 	and.w	r7, r9, #1
 800168a:	461a      	mov	r2, r3
 800168c:	b189      	cbz	r1, 80016b2 <chvprintf+0x1b2>
 800168e:	4283      	cmp	r3, r0
 8001690:	d00f      	beq.n	80016b2 <chvprintf+0x1b2>
 8001692:	b127      	cbz	r7, 800169e <chvprintf+0x19e>
 8001694:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8001698:	3301      	adds	r3, #1
 800169a:	b941      	cbnz	r1, 80016ae <chvprintf+0x1ae>
 800169c:	e009      	b.n	80016b2 <chvprintf+0x1b2>
 800169e:	7851      	ldrb	r1, [r2, #1]
 80016a0:	3301      	adds	r3, #1
 80016a2:	3201      	adds	r2, #1
 80016a4:	b129      	cbz	r1, 80016b2 <chvprintf+0x1b2>
 80016a6:	7851      	ldrb	r1, [r2, #1]
 80016a8:	3301      	adds	r3, #1
 80016aa:	3201      	adds	r2, #1
 80016ac:	b109      	cbz	r1, 80016b2 <chvprintf+0x1b2>
 80016ae:	4283      	cmp	r3, r0
 80016b0:	d1f5      	bne.n	800169e <chvprintf+0x19e>
 80016b2:	ebc8 0003 	rsb	r0, r8, r3
 80016b6:	9004      	str	r0, [sp, #16]
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 80016b8:	f04f 0920 	mov.w	r9, #32
 80016bc:	e009      	b.n	80016d2 <chvprintf+0x1d2>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 80016be:	6833      	ldr	r3, [r6, #0]
 80016c0:	9907      	ldr	r1, [sp, #28]
 80016c2:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 80016c6:	9104      	str	r1, [sp, #16]
 80016c8:	3604      	adds	r6, #4
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 80016ca:	f04f 0920 	mov.w	r9, #32
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80016ce:	f10d 0824 	add.w	r8, sp, #36	; 0x24
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 80016d2:	9804      	ldr	r0, [sp, #16]
 80016d4:	ebc0 010b 	rsb	r1, r0, fp
 80016d8:	ea21 7be1 	bic.w	fp, r1, r1, asr #31
      width = 0;
    if (left_align == FALSE)
 80016dc:	f1ba 0f00 	cmp.w	sl, #0
 80016e0:	d13d      	bne.n	800175e <chvprintf+0x25e>
      width = -width;
 80016e2:	f1cb 0b00 	rsb	fp, fp, #0
    if (width < 0) {
 80016e6:	f1bb 0f00 	cmp.w	fp, #0
 80016ea:	d038      	beq.n	800175e <chvprintf+0x25e>
      if (*s == '-' && filler == '0') {
 80016ec:	f1a9 0330 	sub.w	r3, r9, #48	; 0x30
 80016f0:	f1d3 0e00 	rsbs	lr, r3, #0
 80016f4:	f898 a000 	ldrb.w	sl, [r8]
 80016f8:	eb4e 0703 	adc.w	r7, lr, r3
 80016fc:	f1ba 0f2d 	cmp.w	sl, #45	; 0x2d
 8001700:	bf14      	ite	ne
 8001702:	2700      	movne	r7, #0
 8001704:	f007 0701 	andeq.w	r7, r7, #1
 8001708:	2f00      	cmp	r7, #0
 800170a:	f040 813c 	bne.w	8001986 <chvprintf+0x486>
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800170e:	6828      	ldr	r0, [r5, #0]
 8001710:	ea6f 070b 	mvn.w	r7, fp
 8001714:	6882      	ldr	r2, [r0, #8]
 8001716:	4649      	mov	r1, r9
 8001718:	4628      	mov	r0, r5
 800171a:	f007 0a01 	and.w	sl, r7, #1
 800171e:	4790      	blx	r2
        n++;
      } while (++width != 0);
 8001720:	f11b 0701 	adds.w	r7, fp, #1
 8001724:	d016      	beq.n	8001754 <chvprintf+0x254>
 8001726:	f1ba 0f00 	cmp.w	sl, #0
 800172a:	d006      	beq.n	800173a <chvprintf+0x23a>
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800172c:	6829      	ldr	r1, [r5, #0]
 800172e:	4628      	mov	r0, r5
 8001730:	688b      	ldr	r3, [r1, #8]
 8001732:	4649      	mov	r1, r9
 8001734:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8001736:	3701      	adds	r7, #1
 8001738:	d00c      	beq.n	8001754 <chvprintf+0x254>
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800173a:	6828      	ldr	r0, [r5, #0]
 800173c:	4649      	mov	r1, r9
 800173e:	6882      	ldr	r2, [r0, #8]
 8001740:	4628      	mov	r0, r5
 8001742:	4790      	blx	r2
 8001744:	6829      	ldr	r1, [r5, #0]
        n++;
      } while (++width != 0);
 8001746:	3701      	adds	r7, #1
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8001748:	688b      	ldr	r3, [r1, #8]
 800174a:	4628      	mov	r0, r5
 800174c:	4649      	mov	r1, r9
 800174e:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8001750:	3701      	adds	r7, #1
 8001752:	d1f2      	bne.n	800173a <chvprintf+0x23a>
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001754:	9903      	ldr	r1, [sp, #12]
 8001756:	ebcb 0301 	rsb	r3, fp, r1
 800175a:	9303      	str	r3, [sp, #12]
 800175c:	46bb      	mov	fp, r7
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800175e:	9a04      	ldr	r2, [sp, #16]
 8001760:	2a00      	cmp	r2, #0
 8001762:	dd2d      	ble.n	80017c0 <chvprintf+0x2c0>
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001764:	f8dd e010 	ldr.w	lr, [sp, #16]
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8001768:	4647      	mov	r7, r8
 800176a:	6828      	ldr	r0, [r5, #0]
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 800176c:	eb08 0a0e 	add.w	sl, r8, lr
 8001770:	ea6f 0308 	mvn.w	r3, r8
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8001774:	f817 1b01 	ldrb.w	r1, [r7], #1
 8001778:	eb0a 0203 	add.w	r2, sl, r3
 800177c:	6883      	ldr	r3, [r0, #8]
 800177e:	4628      	mov	r0, r5
 8001780:	f002 0801 	and.w	r8, r2, #1
 8001784:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001786:	4557      	cmp	r7, sl
 8001788:	d016      	beq.n	80017b8 <chvprintf+0x2b8>
 800178a:	f1b8 0f00 	cmp.w	r8, #0
 800178e:	d003      	beq.n	8001798 <chvprintf+0x298>
      streamPut(chp, (uint8_t)*s++);
 8001790:	682b      	ldr	r3, [r5, #0]
 8001792:	f817 1b01 	ldrb.w	r1, [r7], #1
 8001796:	e00a      	b.n	80017ae <chvprintf+0x2ae>
 8001798:	6828      	ldr	r0, [r5, #0]
 800179a:	46b8      	mov	r8, r7
 800179c:	f818 1b01 	ldrb.w	r1, [r8], #1
 80017a0:	6882      	ldr	r2, [r0, #8]
 80017a2:	4628      	mov	r0, r5
 80017a4:	4790      	blx	r2
 80017a6:	682b      	ldr	r3, [r5, #0]
 80017a8:	7879      	ldrb	r1, [r7, #1]
 80017aa:	f108 0701 	add.w	r7, r8, #1
 80017ae:	689a      	ldr	r2, [r3, #8]
 80017b0:	4628      	mov	r0, r5
 80017b2:	4790      	blx	r2
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80017b4:	4557      	cmp	r7, sl
 80017b6:	d1ef      	bne.n	8001798 <chvprintf+0x298>
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80017b8:	9a03      	ldr	r2, [sp, #12]
 80017ba:	9b04      	ldr	r3, [sp, #16]
 80017bc:	18d1      	adds	r1, r2, r3
 80017be:	9103      	str	r1, [sp, #12]
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80017c0:	f1bb 0f00 	cmp.w	fp, #0
 80017c4:	f43f aebb 	beq.w	800153e <chvprintf+0x3e>
      streamPut(chp, (uint8_t)filler);
 80017c8:	682f      	ldr	r7, [r5, #0]
 80017ca:	f10b 38ff 	add.w	r8, fp, #4294967295
 80017ce:	68ba      	ldr	r2, [r7, #8]
 80017d0:	4628      	mov	r0, r5
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80017d2:	4647      	mov	r7, r8
      streamPut(chp, (uint8_t)filler);
 80017d4:	4649      	mov	r1, r9
 80017d6:	f008 0801 	and.w	r8, r8, #1
 80017da:	4790      	blx	r2
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80017dc:	b1b7      	cbz	r7, 800180c <chvprintf+0x30c>
 80017de:	f1b8 0f00 	cmp.w	r8, #0
 80017e2:	d006      	beq.n	80017f2 <chvprintf+0x2f2>
      streamPut(chp, (uint8_t)filler);
 80017e4:	682b      	ldr	r3, [r5, #0]
 80017e6:	4628      	mov	r0, r5
 80017e8:	689a      	ldr	r2, [r3, #8]
 80017ea:	4649      	mov	r1, r9
 80017ec:	4790      	blx	r2
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80017ee:	3f01      	subs	r7, #1
 80017f0:	d00c      	beq.n	800180c <chvprintf+0x30c>
      streamPut(chp, (uint8_t)filler);
 80017f2:	682b      	ldr	r3, [r5, #0]
 80017f4:	4649      	mov	r1, r9
 80017f6:	689a      	ldr	r2, [r3, #8]
 80017f8:	4628      	mov	r0, r5
 80017fa:	4790      	blx	r2
 80017fc:	6828      	ldr	r0, [r5, #0]
      n++;
      width--;
 80017fe:	3f01      	subs	r7, #1
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 8001800:	6883      	ldr	r3, [r0, #8]
 8001802:	4649      	mov	r1, r9
 8001804:	4628      	mov	r0, r5
 8001806:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001808:	3f01      	subs	r7, #1
 800180a:	d1f2      	bne.n	80017f2 <chvprintf+0x2f2>
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 800180c:	9903      	ldr	r1, [sp, #12]
 800180e:	eb0b 0701 	add.w	r7, fp, r1
 8001812:	9703      	str	r7, [sp, #12]
 8001814:	e693      	b.n	800153e <chvprintf+0x3e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001816:	2710      	movs	r7, #16
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8001818:	6832      	ldr	r2, [r6, #0]
 800181a:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
 800181e:	3604      	adds	r6, #4
 8001820:	4611      	mov	r1, r2
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 8001822:	fbb2 fcf7 	udiv	ip, r2, r7
 8001826:	fb07 281c 	mls	r8, r7, ip, r2
    i += '0';
 800182a:	f108 0330 	add.w	r3, r8, #48	; 0x30
    if (i > '9')
 800182e:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8001830:	bfc8      	it	gt
 8001832:	f108 0337 	addgt.w	r3, r8, #55	; 0x37
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
 8001836:	fbb1 f1f7 	udiv	r1, r1, r7
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 800183a:	4680      	mov	r8, r0
    l /= radix;
 800183c:	4662      	mov	r2, ip
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 800183e:	f800 3901 	strb.w	r3, [r0], #-1
    l /= radix;
  } while ((ll /= radix) != 0);
 8001842:	2900      	cmp	r1, #0
 8001844:	d1ed      	bne.n	8001822 <chvprintf+0x322>

  i = (int)(p + MAX_FILLER - q);
 8001846:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 800184a:	af09      	add	r7, sp, #36	; 0x24
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
 800184c:	ebc8 0c00 	rsb	ip, r8, r0
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001850:	eb07 000c 	add.w	r0, r7, ip
 8001854:	9f02      	ldr	r7, [sp, #8]
 8001856:	43f9      	mvns	r1, r7
 8001858:	1842      	adds	r2, r0, r1
 800185a:	07d2      	lsls	r2, r2, #31
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 800185c:	a909      	add	r1, sp, #36	; 0x24
 800185e:	d50f      	bpl.n	8001880 <chvprintf+0x380>
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 8001860:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 8001864:	f10d 0125 	add.w	r1, sp, #37	; 0x25
  while (--i);
 8001868:	f818 3f01 	ldrb.w	r3, [r8, #1]!
 800186c:	e008      	b.n	8001880 <chvprintf+0x380>
 800186e:	f898 7001 	ldrb.w	r7, [r8, #1]
 8001872:	f108 0301 	add.w	r3, r8, #1
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 8001876:	704f      	strb	r7, [r1, #1]
  while (--i);
 8001878:	785b      	ldrb	r3, [r3, #1]
 800187a:	f108 0802 	add.w	r8, r8, #2
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 800187e:	1c51      	adds	r1, r2, #1
 8001880:	460a      	mov	r2, r1
 8001882:	f802 3b01 	strb.w	r3, [r2], #1
  while (--i);
 8001886:	4282      	cmp	r2, r0
 8001888:	d1f1      	bne.n	800186e <chvprintf+0x36e>
 800188a:	f8cd c010 	str.w	ip, [sp, #16]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800188e:	f10d 0824 	add.w	r8, sp, #36	; 0x24
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
 8001892:	e71e      	b.n	80016d2 <chvprintf+0x1d2>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8001894:	6832      	ldr	r2, [r6, #0]
 8001896:	3604      	adds	r6, #4
      if (l < 0) {
 8001898:	2a00      	cmp	r2, #0
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 800189a:	bfa8      	it	ge
 800189c:	f10d 0824 	addge.w	r8, sp, #36	; 0x24
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
 80018a0:	f2c0 8082 	blt.w	80019a8 <chvprintf+0x4a8>
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 80018a4:	f108 0c0b 	add.w	ip, r8, #11
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80018a8:	f8cd 8010 	str.w	r8, [sp, #16]
 80018ac:	f8dd 8018 	ldr.w	r8, [sp, #24]
 80018b0:	4661      	mov	r1, ip
 80018b2:	4617      	mov	r7, r2
 80018b4:	f8cd c000 	str.w	ip, [sp]
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 80018b8:	fba8 c302 	umull	ip, r3, r8, r2
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
 80018bc:	fba8 c707 	umull	ip, r7, r8, r7
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 80018c0:	08db      	lsrs	r3, r3, #3
 80018c2:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 80018c6:	eba2 0040 	sub.w	r0, r2, r0, lsl #1
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80018ca:	3901      	subs	r1, #1
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
    i += '0';
 80018cc:	3030      	adds	r0, #48	; 0x30
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
 80018ce:	08ff      	lsrs	r7, r7, #3
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 80018d0:	7008      	strb	r0, [r1, #0]
    l /= radix;
 80018d2:	461a      	mov	r2, r3
  } while ((ll /= radix) != 0);
 80018d4:	d1f0      	bne.n	80018b8 <chvprintf+0x3b8>
 80018d6:	f8dd c000 	ldr.w	ip, [sp]
 80018da:	f8dd 8010 	ldr.w	r8, [sp, #16]

  i = (int)(p + MAX_FILLER - q);
 80018de:	ebc1 0c0c 	rsb	ip, r1, ip
 80018e2:	ea6f 0208 	mvn.w	r2, r8
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80018e6:	eb08 070c 	add.w	r7, r8, ip
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
 80018ea:	f8cd c010 	str.w	ip, [sp, #16]
 80018ee:	eb07 0c02 	add.w	ip, r7, r2
 80018f2:	ea5f 73cc 	movs.w	r3, ip, lsl #31
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80018f6:	4642      	mov	r2, r8
 80018f8:	d511      	bpl.n	800191e <chvprintf+0x41e>
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 80018fa:	4642      	mov	r2, r8
 80018fc:	f802 0b01 	strb.w	r0, [r2], #1
  while (--i);
 8001900:	f811 0f01 	ldrb.w	r0, [r1, #1]!
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 8001904:	4613      	mov	r3, r2
 8001906:	f803 0b01 	strb.w	r0, [r3], #1
  while (--i);
 800190a:	42bb      	cmp	r3, r7
 800190c:	d00c      	beq.n	8001928 <chvprintf+0x428>
 800190e:	f891 c001 	ldrb.w	ip, [r1, #1]
 8001912:	1c48      	adds	r0, r1, #1
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 8001914:	f882 c001 	strb.w	ip, [r2, #1]
  while (--i);
 8001918:	7840      	ldrb	r0, [r0, #1]
 800191a:	3102      	adds	r1, #2
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 800191c:	1c5a      	adds	r2, r3, #1
 800191e:	4613      	mov	r3, r2
 8001920:	f803 0b01 	strb.w	r0, [r3], #1
  while (--i);
 8001924:	42bb      	cmp	r3, r7
 8001926:	d1f2      	bne.n	800190e <chvprintf+0x40e>
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
        l = -l;
      }
      p = ch_ltoa(p, l, 10);
 8001928:	9a04      	ldr	r2, [sp, #16]
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
  while (--i);
 800192a:	9b02      	ldr	r3, [sp, #8]
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
        l = -l;
      }
      p = ch_ltoa(p, l, 10);
 800192c:	eb08 0102 	add.w	r1, r8, r2
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
  while (--i);
 8001930:	ebc3 0801 	rsb	r8, r3, r1
 8001934:	f8cd 8010 	str.w	r8, [sp, #16]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001938:	f10d 0824 	add.w	r8, sp, #36	; 0x24
      if (l < 0) {
        *p++ = '-';
        l = -l;
      }
      p = ch_ltoa(p, l, 10);
      break;
 800193c:	e6c9      	b.n	80016d2 <chvprintf+0x1d2>
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 800193e:	9a07      	ldr	r2, [sp, #28]
 8001940:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 8001944:	9204      	str	r2, [sp, #16]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001946:	f10d 0824 	add.w	r8, sp, #36	; 0x24
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
 800194a:	e6c2      	b.n	80016d2 <chvprintf+0x1d2>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800194c:	270a      	movs	r7, #10
 800194e:	e763      	b.n	8001818 <chvprintf+0x318>
 8001950:	2708      	movs	r7, #8
 8001952:	e761      	b.n	8001818 <chvprintf+0x318>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 8001954:	4620      	mov	r0, r4
 8001956:	2100      	movs	r1, #0
      while (TRUE) {
        c = *fmt++;
 8001958:	f810 3b01 	ldrb.w	r3, [r0], #1
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 800195c:	eb01 0781 	add.w	r7, r1, r1, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 8001960:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
 8001964:	b2e2      	uxtb	r2, r4
 8001966:	2a09      	cmp	r2, #9
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 8001968:	4604      	mov	r4, r0
        if (c >= '0' && c <= '9')
 800196a:	d904      	bls.n	8001976 <chvprintf+0x476>
          c -= '0';
        else if (c == '*')
 800196c:	2b2a      	cmp	r3, #42	; 0x2a
 800196e:	f47f ae24 	bne.w	80015ba <chvprintf+0xba>
          c = va_arg(ap, int);
 8001972:	7832      	ldrb	r2, [r6, #0]
 8001974:	3604      	adds	r6, #4
        else
          break;
        precision *= 10;
        precision += c;
 8001976:	eb02 0147 	add.w	r1, r2, r7, lsl #1
      }
 800197a:	e7ed      	b.n	8001958 <chvprintf+0x458>
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
 800197c:	1ca7      	adds	r7, r4, #2
 800197e:	78a3      	ldrb	r3, [r4, #2]
      left_align = TRUE;
 8001980:	f04f 0a01 	mov.w	sl, #1
 8001984:	e5f9      	b.n	800157a <chvprintf+0x7a>
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        streamPut(chp, (uint8_t)*s++);
 8001986:	682b      	ldr	r3, [r5, #0]
 8001988:	212d      	movs	r1, #45	; 0x2d
 800198a:	4628      	mov	r0, r5
 800198c:	689f      	ldr	r7, [r3, #8]
 800198e:	47b8      	blx	r7
        n++;
 8001990:	9903      	ldr	r1, [sp, #12]
        i--;
 8001992:	f8dd a010 	ldr.w	sl, [sp, #16]
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        streamPut(chp, (uint8_t)*s++);
        n++;
 8001996:	1c4a      	adds	r2, r1, #1
        i--;
 8001998:	f10a 3cff 	add.w	ip, sl, #4294967295
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        streamPut(chp, (uint8_t)*s++);
 800199c:	f108 0801 	add.w	r8, r8, #1
        n++;
 80019a0:	9203      	str	r2, [sp, #12]
        i--;
 80019a2:	f8cd c010 	str.w	ip, [sp, #16]
 80019a6:	e6b2      	b.n	800170e <chvprintf+0x20e>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 80019a8:	272d      	movs	r7, #45	; 0x2d
 80019aa:	f88d 7024 	strb.w	r7, [sp, #36]	; 0x24
        l = -l;
 80019ae:	4252      	negs	r2, r2
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 80019b0:	f10d 0825 	add.w	r8, sp, #37	; 0x25
 80019b4:	e776      	b.n	80018a4 <chvprintf+0x3a4>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80019b6:	9304      	str	r3, [sp, #16]
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 80019b8:	f04f 0920 	mov.w	r9, #32
 80019bc:	e689      	b.n	80016d2 <chvprintf+0x1d2>
 80019be:	bf00      	nop

080019c0 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80019c0:	b40e      	push	{r1, r2, r3}
 80019c2:	b500      	push	{lr}
 80019c4:	b082      	sub	sp, #8
 80019c6:	ab03      	add	r3, sp, #12
 80019c8:	f853 1b04 	ldr.w	r1, [r3], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 80019cc:	461a      	mov	r2, r3
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80019ce:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80019d0:	f7ff fd96 	bl	8001500 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80019d4:	b002      	add	sp, #8
 80019d6:	f85d eb04 	ldr.w	lr, [sp], #4
 80019da:	b003      	add	sp, #12
 80019dc:	4770      	bx	lr
 80019de:	bf00      	nop

080019e0 <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80019e0:	f640 0000 	movw	r0, #2048	; 0x800
 80019e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80019e8:	6982      	ldr	r2, [r0, #24]
 80019ea:	f641 33b0 	movw	r3, #7088	; 0x1bb0
/*
 * Blinker thread #1.
 */

static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 80019ee:	b570      	push	{r4, r5, r6, lr}
 80019f0:	f6c0 0300 	movt	r3, #2048	; 0x800
    (void)arg;

    chRegSetThreadName("blinker");

    while (true) {
        palSetPad(GPIOD, 2);
 80019f4:	f44f 54a0 	mov.w	r4, #5120	; 0x1400
 80019f8:	2504      	movs	r5, #4
 80019fa:	6193      	str	r3, [r2, #24]
 80019fc:	f2c4 0401 	movt	r4, #16385	; 0x4001
 8001a00:	462e      	mov	r6, r5
        chThdSleepMilliseconds(150);
 8001a02:	2096      	movs	r0, #150	; 0x96
    (void)arg;

    chRegSetThreadName("blinker");

    while (true) {
        palSetPad(GPIOD, 2);
 8001a04:	6126      	str	r6, [r4, #16]
        chThdSleepMilliseconds(150);
 8001a06:	f7fe ff8b 	bl	8000920 <chThdSleep>
        palClearPad(GPIOD, 2);
 8001a0a:	6165      	str	r5, [r4, #20]
        chThdSleepMilliseconds(150);
 8001a0c:	2096      	movs	r0, #150	; 0x96
 8001a0e:	f7fe ff87 	bl	8000920 <chThdSleep>
 8001a12:	e7f6      	b.n	8001a02 <Thread1+0x22>
 8001a14:	f3af 8000 	nop.w
 8001a18:	f3af 8000 	nop.w
 8001a1c:	f3af 8000 	nop.w

08001a20 <main>:

/*===========================================================================*/
/* Initialization and main thread.                                           */
/*===========================================================================*/

int main(void) {
 8001a20:	b510      	push	{r4, lr}
 8001a22:	b082      	sub	sp, #8
		*   and performs the board-specific initializations.
		* - Kernel initialization, the main() function becomes a thread and the
		*   RTOS is active.
		*/

    halInit();
 8001a24:	f7ff fa24 	bl	8000e70 <halInit>
    chSysInit();
 8001a28:	f7fe fcb2 	bl	8000390 <chSysInit>
    boardInit();
 8001a2c:	f7ff fd60 	bl	80014f0 <boardInit>
    /*
    * Activates the serial driver 1 using the driver default configuration.
    * PA9(TX) and PA10(RX) are routed to USART1.
    */

    sdStart(&SD3, NULL);
 8001a30:	f640 10f0 	movw	r0, #2544	; 0x9f0
 8001a34:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001a38:	2100      	movs	r1, #0
 8001a3a:	f7ff fac1 	bl	8000fc0 <sdStart>

    /*
    * Creates the example threads.
    */

    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO+1, Thread1, NULL);
 8001a3e:	f640 2068 	movw	r0, #2664	; 0xa68
 8001a42:	f641 13e1 	movw	r3, #6625	; 0x19e1
 8001a46:	2400      	movs	r4, #0
 8001a48:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001a4c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001a50:	2241      	movs	r2, #65	; 0x41
 8001a52:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001a56:	9400      	str	r4, [sp, #0]
 8001a58:	f7fe ff4a 	bl	80008f0 <chThdCreateStatic>

    // Change to
    while (RUN_MAIN_THREAD) {
		
		// ...
		chprintf((BaseChannel *)&SD3, "Waiting for BD confirmation \n\r");
 8001a5c:	f640 10f0 	movw	r0, #2544	; 0x9f0
 8001a60:	f641 31b8 	movw	r1, #7096	; 0x1bb8
 8001a64:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001a68:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001a6c:	f7ff ffa8 	bl	80019c0 <chprintf>
        chThdSleepMilliseconds(5000);
 8001a70:	f241 3088 	movw	r0, #5000	; 0x1388
 8001a74:	f7fe ff54 	bl	8000920 <chThdSleep>
 8001a78:	e7f0      	b.n	8001a5c <main+0x3c>
 8001a7a:	bf00      	nop
 8001a7c:	f3af 8000 	nop.w

08001a80 <ram_areas>:
 8001a80:	1be0 0800 0bb0 2000 0bb0 2000 0bb0 2000     ....... ... ... 
 8001a90:	1be0 0800 0000 0000 0000 0000 0000 0000     ................
 8001aa0:	1be0 0800 0000 0000 0000 0000 0000 0000     ................
 8001ab0:	1be0 0800 0000 0000 0000 0000 0000 0000     ................
 8001ac0:	1be0 0800 0000 0000 0000 0000 0000 0000     ................
 8001ad0:	1be0 0800 0000 0000 0000 0000 0000 0000     ................
 8001ae0:	1be0 0800 0000 0000 0000 0000 0000 0000     ................
 8001af0:	1be0 0800 0000 0000 0000 0000 0000 0000     ................
 8001b00:	6469 656c 0000 0000 0000 0000 0000 0000     idle............

08001b10 <ch_debug>:
 8001b10:	616d 6e69 1600 1880 0204 0844 100c 1814     main......D.....
 8001b20:	1c00 1e1d 0000 0000 0000 0000 0000 0000     ................

08001b30 <vmt>:
 8001b30:	0f11 0800 0ef1 0800 0f51 0800 0f31 0800     ........Q...1...
 8001b40:	0f41 0800 0f21 0800 0f01 0800 0ee1 0800     A...!...........

08001b50 <default_config>:
 8001b50:	c200 0001 0000 4000 0000 0000 0000 0000     .......@........

08001b60 <pal_default_config>:
 8001b60:	ffff ffff 4b84 b4b3 84b8 8888 ffff ffff     .....K..........
 8001b70:	8888 8888 8888 b4b3 fcff ffff 8888 8888     ................
 8001b80:	4b33 8888 ffff ffff 8344 8888 8888 8888     3K......D.......
 8001b90:	ffff ffff 8888 8888 8888 8888 0000 0000     ................
 8001ba0:	6e28 6c75 296c 0000 0000 0000 0000 0000     (null)..........
 8001bb0:	6c62 6e69 656b 0072 6157 7469 6e69 2067     blinker.Waiting 
 8001bc0:	6f66 2072 4442 6320 6e6f 6966 6d72 7461     for BD confirmat
 8001bd0:	6f69 206e 0d0a 0000 3031 0000               ion ....10..
